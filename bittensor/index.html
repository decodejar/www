<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAO Tensor Law Model</title>
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Internal Styles -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Loader animation */
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ff6d00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Colored status dot */
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        /* --- Fullscreen CSS Logic --- */
        
        /* Override body flex-centering when in fullscreen */
        body:has(#mainContainer:fullscreen) {
            display: block;
        }

        /* Main container expands to fill viewport in fullscreen */
        #mainContainer:fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none !important;
            border-radius: 0 !important;
            display: flex;
            flex-direction: column;
        }

        /* Chart card grows to fill available space */
        #mainContainer:fullscreen #chartCard {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* Chart wrapper (which contains canvas) grows */
        #mainContainer:fullscreen #chartWrapper {
            height: 100% !important;
            flex-grow: 1;
        }

        /* Hide footer when in fullscreen */
        body:has(#mainContainer:fullscreen) footer {
            display: none;
        }

        /* --- Mobile Fullscreen Optimizations --- */

        /* Show "Please Rotate" overlay in portrait fullscreen */
        @media (max-width: 639px) and (orientation: portrait) {
            #mainContainer:fullscreen #rotateOverlay {
                display: flex !important;
            }
            /* Hide all other UI elements */
            #mainContainer:fullscreen header,
            #mainContainer:fullscreen #topStatusBar,
            #mainContainer:fullscreen #chartCard,
            #mainContainer:fullscreen #bottomModelBar,
            #mainContainer:fullscreen #fullscreenBtn {
                display: none !important;
            }
        }

        /* Styles applied by JS for mobile LANDSCAPE fullscreen */
        #mainContainer.mobile-fullscreen-landscape header,
        #mainContainer.mobile-fullscreen-landscape #bottomModelBar {
             display: none !important;
        }
         #mainContainer.mobile-fullscreen-landscape #chartCard {
             padding: 0 !important;
         }
         #mainContainer.mobile-fullscreen-landscape #topStatusBar {
             display: flex !important;
         }
        /* --- END: Mobile Fullscreen Optimizations --- */

        /* --- Projection Table Styles --- */
        #projectionTable {
            position: absolute;
            top: 12%;
            left: 10%;
            z-index: 5; /* Below loader (10) but above chart */
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.5rem 0.75rem; /* p-2 p-3 */
            font-size: 0.75rem; /* text-xs */
            line-height: 1.15rem;
            color: #374151; /* text-gray-700 */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* shadow-md */
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        #projectionTable h3 {
            font-weight: 600; /* font-semibold */
            color: #1f2937; /* text-gray-800 */
            margin-bottom: 0.25rem; /* mb-1 */
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #projectionTable div {
            display: flex;
            justify-content: space-between;
        }
        #projectionTable div span:first-child {
            margin-right: 1.25rem; /* mr-5 */
            color: #4b5563; /* text-gray-600 */
        }
        #projectionTable div span:last-child {
            font-weight: 500; /* font-medium */
            color: #1f2937; /* text-gray-800 */
        }
        #projectionTable h3 button {
            margin-left: 0.5rem; /* ml-2 */
            color: #9ca3af; /* text-gray-400 */
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }
         #projectionTable h3 button:hover {
           color: #374151; /* hover:text-gray-700 */
         }
        /* --- END: Projection Table Styles --- */
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center h-screen p-2">

    <!-- 
      Main application container.
     -->
    <div id="mainContainer" class="w-full flex-grow max-w-[1920px] max-h-[1080px] min-h-[30rem] flex flex-col bg-white rounded-lg shadow-xl p-2 sm:p-3 md:p-4 relative">

        <!-- Overlay to show on mobile fullscreen portrait -->
        <div id="rotateOverlay" class="hidden absolute inset-0 w-full h-full bg-white/95 z-50 flex-col items-center justify-center text-center p-8">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 text-gray-600 mb-4 animate-pulse">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.992 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
            <h2 class="text-2xl font-semibold text-gray-800 mb-2">Please Rotate Your Device</h2>
            <p class="text-gray-600">This chart is best viewed in landscape mode.</p>
        </div>

        <!-- Fullscreen toggle button -->
        <button id="fullscreenBtn" onclick="toggleFullScreen()" class="absolute top-4 right-4 sm:top-6 sm:right-6 text-gray-400 hover:text-gray-800 transition-colors z-20 p-1 rounded-full hover:bg-gray-100" title="Toggle Fullscreen">
            <svg id="fsIconEnter" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m4.5 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
            </svg>
            <svg id="fsIconExit" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 hidden">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 9L3.75 3.75M9 9h4.5m-4.5 0v4.5m0-4.5L3.75 3.75M9 15l-5.25 5.25M9 15h4.5m-4.5 0v-4.5m0 4.5l-5.25 5.25M15 9l5.25-5.25M15 9h-4.5m4.5 0v4.5m0-4.5l5.25-5.25M15 15l5.25 5.25M15 15h-4.5m4.5 0v-4.5m0 4.5l5.25 5.25" />
            </svg>
        </button>
        
        <!-- Page Header -->
        <header class="text-center mb-3">
            <h1 class="text-xl sm:text-2xl md:text-3xl text-gray-900">TAO Tensor Law Model</h1>
        </header>

        <!-- Top Status Bar: Data status, price, bands toggle -->
        <div id="topStatusBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mb-2 text-sm text-gray-600 px-4">
             <div id="statusDiv" class="flex items-center">
                 <span class="status-dot bg-yellow-400"></span>Loading latest data...
             </div>
             <div id="lastUpdateDiv" class="hidden sm:block"></div>
             <div id="lastPriceDiv" class="hidden sm:block"></div>
             <div id="priceZoneDiv" class="flex items-center hidden sm:block"></div>
             
             <!-- Bands Toggle Checkbox -->
             <div id="showBandsContainer" class="flex items-center hidden">
                 <input type="checkbox" id="showBandsCheckbox" class="mr-1.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                 <label for="showBandsCheckbox" class="cursor-pointer mr-1">Bands&nbsp;</label>
                 <span title="Blue: Discount (P1-P20), Green: Value (P20-P50), Yellow: Expensive (P50-P80), Red: Bubble (P80-P99)" class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
             </div>
        </div>

        <!-- Chart Card: Contains loader and canvas wrapper -->
        <div id="chartCard" class="bg-white p-2 rounded-lg relative flex-grow flex flex-col min-h-0">
            <!-- Loading Spinner -->
            <div id="loader" class="absolute inset-0 bg-white/80 flex items-center justify-center z-10">
                <div class="loader"></div>
            </div>
            <!-- Canvas Wrapper: Scales to fill parent card -->
            <div id="chartWrapper" class="relative flex-grow min-h-0">
                <div id="projectionTable" class="hidden"></div>
                <canvas id="powerLawChart"></canvas>
            </div>

            <!-- Bottom Model Info Bar: Model parameters -->
            <div id="bottomModelBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mt-2 text-sm text-gray-600">
                <!-- NEW: Model Selection Dropdown -->
                <div class="flex items-center">
                    <label for="modelSelect" class="mr-1.5"><strong>Method:</strong></label>
                    <select id="modelSelect" class="text-sm rounded border-gray-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="hardcoded">Default Offset</option>
                        <option value="optimalOffset" selected>Optimal Offset</option>
                        <option value="mleTruncation">Optimal Truncation</option>
                    </select>
                </div>
                <div id="modelParamDiv"></div> <!-- Renamed from optimalOffsetDiv -->
                <div id="growthExponentDiv"></div>
                <div id="modelFitDiv"></div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center p-1 mt-2">
        <p class="text-gray-600 text-xs">&copy; 2025 <a href="https://decodejar.com" target="_blank" rel="noopener noreferrer" class="hover:text-indigo-500 transition-colors">DECODEJAR.COM</a>. All Rights Reserved. Disclaimer: This tool is for informational and research purposes only and does not constitute financial or trading advice. Past performance is not indicative of future results.</p>
    </footer>

<script>
        /*
         * TAO Tensor Law Model & Regression Logic
         * Copyright (c) 2025 Decodejar.com. All Rights Reserved.
         */

        // --- Global Element References ---
        const growthExponentDiv = document.getElementById('growthExponentDiv');
        const modelFitDiv = document.getElementById('modelFitDiv');
        const loader = document.getElementById('loader');
        const statusDiv = document.getElementById('statusDiv');
        const lastUpdateDiv = document.getElementById('lastUpdateDiv');
        const lastPriceDiv = document.getElementById('lastPriceDiv');
        const priceZoneDiv = document.getElementById('priceZoneDiv');
        const ctx = document.getElementById('powerLawChart').getContext('2d');
        const modelParamDiv = document.getElementById('modelParamDiv'); // Renamed
        const showBandsContainer = document.getElementById('showBandsContainer');
        const showBandsCheckbox = document.getElementById('showBandsCheckbox');
        const projectionTable = document.getElementById('projectionTable');
        const modelSelect = document.getElementById('modelSelect'); // NEW

        // --- Chart Configuration ---
        const HARDCODED_OFFSET = 75; // Renamed from DAY_OFFSET
        const MIN_DATA_POINTS_FOR_TRUNCATION = 30; // Min data points for Truncation model
        const MAX_TRUNCATION_SEARCH_DAYS = 180; // NEW: Max days from start to test truncation
        const MAX_OFFSET_SEARCH_LIMIT = 730; // NEW: Max offset value to test
        let chart; // Global chart instance
        let baseData = []; // NEW: Made global for tooltip scope
        let activeModelParams = {}; // NEW: Stores params of the active model

        // Band Fill Colors
        const blueFillColor = 'rgba(147, 197, 253, 0.1)';
        const greenFillColor = 'rgba(34, 197, 94, 0.1)';
        const yellowFillColor = 'rgba(250, 204, 21, 0.1)';
        const redFillColor = 'rgba(239, 68, 68, 0.1)';

        // Reusable Line Styles
        const grayLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 1 };
        const orangeLineStyle = { borderColor: '#ff6d00', borderWidth: 2 };
        const grayDashedLineStyle = { borderColor: 'rgba(156, 163, 175, 0.9)', borderWidth: 1, borderDash: [2, 2] };
        const grayFineLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 0.5, borderDash: [] };

        /**
         * Fetches and parses price data from JSON file.
         */
        async function loadPriceData() {
            try {
                const response = await fetch(`./price_data.json?t=${new Date().getTime()}`); // Cache-bust
                if (!response.ok) throw new Error(`Failed to load data file: ${response.statusText}`);
                const data = await response.json();
                 if (!Array.isArray(data)) throw new Error("Invalid data format in JSON file");
                return data.map((p, i) => ({ time: p[0] * 1000, dayIndex: i + 1, y: p[1] })).filter(p => p.y > 0);
            } catch (error) {
                console.error("Error loading price data:", error);
                statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>Error loading data. Check console.`;
                loader.style.display = 'none';
                return null;
            }
        }

        /**
         * Performs linear regression on log-transformed data.
         */
        function linearRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            const n = validData.length;
            if (n < 2) return { slope: 0, intercept: 0 }; 
            
            for (const { x, y } of validData) {
                const logX = Math.log10(x);
                const logY = Math.log10(y);
                sumX += logX; sumY += logY; sumXY += logX * logY; sumX2 += logX * logX;
            }

            const denominator = (n * sumX2 - sumX * sumX);
            if (denominator === 0) return { slope: 0, intercept: 0 }; 
            
            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept };
        }

        /**
         * Calculates sorted residuals (logY - predictedLogY) from the mean regression line.
         */
        function calculateResiduals(data, slope, intercept) {
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length === 0) return [];
            return validData.map(p => {
                const logX = Math.log10(p.x);
                const logY = Math.log10(p.y);
                const predictedLogY = slope * logX + intercept;
                return logY - predictedLogY;
            }).sort((a, b) => a - b); 
        }

        /**
         * Gets a specific percentile value from a pre-sorted array of residuals.
         */
        function getPercentile(sortedResiduals, percentile) {
            if (!sortedResiduals || sortedResiduals.length === 0) return 0;
            const index = (percentile / 100) * (sortedResiduals.length - 1);
            const lowerIndex = Math.floor(index);
            const upperIndex = Math.ceil(index);
            
            if (lowerIndex === upperIndex) {
                 return sortedResiduals[lowerIndex];
            } else {
                 const weight = index - lowerIndex;
                 return sortedResiduals[lowerIndex] * (1 - weight) + sortedResiduals[upperIndex] * weight;
            }
        }

        /**
         * Finds the optimal day offset by testing a range of values.
         */
        function findOptimalOffset(baseData, minOffset = 1, maxOffset) {
            let bestOffset = -1;
            let bestRSquared = -Infinity;

            if (baseData.length < 2) return { optimalOffset: -1, bestFit: 0 };
            if (typeof maxOffset === 'undefined' || maxOffset < minOffset) maxOffset = baseData.length; 

            for (let offset = minOffset; offset <= maxOffset; offset++) {
                const offsetData = baseData.map(p => ({ x: p.dayIndex + offset, y: p.y }));
                const { slope, intercept } = linearRegression(offsetData);
                if (slope === 0 && intercept === 0 && offsetData.length > 1) continue; 
                
                const rSquared = calculateRSquared(offsetData, slope, intercept);
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestOffset = offset;
                }
            }
            return { optimalOffset: bestOffset, bestFit: bestRSquared };
        }

        /**
         * NEW: Finds the optimal start day (truncation) by testing different start points.
         */
        function findOptimalTruncation(baseData) {
            let bestStartIndex = -1;
            let bestRSquared = -Infinity;
            let bestSlope = 0;
            let bestIntercept = 0;

            // Ensure we have at least MIN_DATA_POINTS_FOR_TRUNCATION days to regress on
            const maxStartIndexByMinData = baseData.length - MIN_DATA_POINTS_FOR_TRUNCATION;
            // NEW: Limit the search to the first MAX_TRUNCATION_SEARCH_DAYS
            const maxStartIndex = Math.min(maxStartIndexByMinData, MAX_TRUNCATION_SEARCH_DAYS);
            
            if (maxStartIndex < 0) {
                return { bestStartIndex: 0, slope: 0, intercept: 0, bestFit: 0 };
            }

            for (let startIndex = 0; startIndex <= maxStartIndex; startIndex++) {
                const truncatedData = baseData.slice(startIndex);
                // For truncation, x *is* the dayIndex (no offset)
                const regressionData = truncatedData.map(p => ({ x: p.dayIndex, y: p.y }));
                
                const { slope, intercept } = linearRegression(regressionData);
                if (slope === 0 && intercept === 0 && regressionData.length > 1) continue;

                const rSquared = calculateRSquared(regressionData, slope, intercept);
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestStartIndex = startIndex;
                    bestSlope = slope;
                    bestIntercept = intercept;
                }
            }
            return { bestStartIndex, slope: bestSlope, intercept: bestIntercept, bestFit: bestRSquared };
        }


        /**
         * Main function to load data, run calculations, and create or update the chart.
         */
        async function createOrUpdateChart() {
            loader.style.display = 'flex';
            const baseData = await loadPriceData();

            if (!baseData || baseData.length === 0) {
                 if (!statusDiv.innerHTML.includes('Error')) {
                     statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>No valid data to display.`;
                 }
                 growthExponentDiv.innerHTML = '<strong>Exponent (α):</strong> N/A';
                 modelParamDiv.innerHTML = '<strong>Model:</strong> N/A';
                 modelFitDiv.innerHTML = '<strong>Fit (R²):</strong> N/A';
                 if (modelSelect) modelSelect.disabled = true;
                 showBandsContainer.classList.add('hidden');
                 loader.style.display = 'none';
                 return;
            }

            // --- 1. GET MODEL PARAMETERS BASED ON SELECTION ---
            const selectedModel = modelSelect.value;
            let priceData, slope, meanIntercept, rSquared;
            
            // Store results in the global activeModelParams
            activeModelParams = {
                modelType: selectedModel,
                activeDayOffset: 0, // Default to 0, will be set by offset models
                truncationStartIndex: 0 // Default to 0, will be set by truncation model
            };

            // Find optimal offset, but only search up to our defined limit
            const { optimalOffset, bestFit: optimalOffsetRSquared } = findOptimalOffset(baseData, 1, MAX_OFFSET_SEARCH_LIMIT);

            // NEW: Define chartPriceData here, based on the *full* baseData
            let chartPriceData;

            switch (selectedModel) {
                case 'optimalOffset': {
                    activeModelParams.activeDayOffset = optimalOffset;
                    priceData = baseData.map(p => ({ ...p, x: p.dayIndex + optimalOffset }));
                    chartPriceData = priceData; // For this model, they are the same
                    const regression = linearRegression(priceData);
                    slope = regression.slope;
                    meanIntercept = regression.intercept;
                    rSquared = optimalOffsetRSquared; // We already have this
                    modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${optimalOffset}`;
                    break;
                }
                
                case 'hardcoded': {
                    activeModelParams.activeDayOffset = HARDCODED_OFFSET;
                    priceData = baseData.map(p => ({ ...p, x: p.dayIndex + HARDCODED_OFFSET }));
                    chartPriceData = priceData; // For this model, they are the same
                    const regression = linearRegression(priceData);
                    slope = regression.slope;
                    meanIntercept = regression.intercept;
                    rSquared = calculateRSquared(priceData, slope, meanIntercept);
                    // Show comparison to optimal
                    if (optimalOffset !== -1 && optimalOffset !== HARDCODED_OFFSET) {
                         modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${HARDCODED_OFFSET} | <strong>Optimal:</strong> ${optimalOffset} (R² ${optimalOffsetRSquared.toFixed(4)})`;
                    } else {
                         modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${HARDCODED_OFFSET}`;
                    }
                    break;
                }
                
                case 'mleTruncation': {
                    const { bestStartIndex, slope: truncSlope, intercept: truncIntercept, bestFit: truncRSquared } = findOptimalTruncation(baseData);
                    activeModelParams.truncationStartIndex = bestStartIndex;
                    activeModelParams.startDayIndex = baseData[bestStartIndex].dayIndex; // NEW: Store the actual start day
                    // priceData is for the *regression*
                    priceData = baseData.slice(bestStartIndex).map(p => ({ ...p, x: p.dayIndex }));
                    // chartPriceData is for *plotting* - use ALL data
                    chartPriceData = baseData.map(p => ({ ...p, x: p.dayIndex }));
                    slope = truncSlope;
                    meanIntercept = truncIntercept;
                    rSquared = truncRSquared;
                    modelParamDiv.innerHTML = `<strong>Start Day:</strong> ${baseData[bestStartIndex].dayIndex}`;
                    break;
                }
            }
            
            // Store final model params
            activeModelParams.slope = slope;
            activeModelParams.meanIntercept = meanIntercept;

            // --- 2. UPDATE UI & CALCULATE AXES (using model data) ---
            if (modelSelect) modelSelect.disabled = false;
            
            // NEW: Use the *last point of the full baseData* for UI
            const lastBaseDataPoint = baseData[baseData.length - 1];
            const lastTimestamp = lastBaseDataPoint.time; 
            const lastUpdateDate = new Date(lastTimestamp).toLocaleDateString(undefined, {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            statusDiv.innerHTML = `<span class="status-dot bg-green-500"></span>Data Loaded`;
            lastUpdateDiv.innerHTML = `<strong>Updated:</strong> ${lastUpdateDate}`;
            lastPriceDiv.innerHTML = `<strong>Price:</strong> $${lastBaseDataPoint.y.toFixed(2)}`;
            lastUpdateDiv.classList.remove('hidden');
            lastPriceDiv.classList.remove('hidden');

            // NEW: Calculate axis ranges based on the *full chartPriceData*
            const chartPrices = chartPriceData.map(p => p.y);
            const minPrice = Math.min(...chartPrices);
            const maxPrice = Math.max(...chartPrices);

            // X-Axis Range (with projection)
            const n = chartPriceData.length; // Use full data length
            const firstDayNum = chartPriceData[0].x;
            const firstDayTime = chartPriceData[0].time;
            const lastDayNum = chartPriceData[n - 1].x; // Use last point of full data
            const lastDayTime = chartPriceData[n - 1].time;

            const timeDuration = lastDayTime - firstDayTime;
            const extendedMaxTime = lastDayTime + (timeDuration * 1); // 100% projection
            const futureTimeIndexRatio = (timeDuration > 0) ? (extendedMaxTime - firstDayTime) / timeDuration : 1;
            
            const dayNumDuration = lastDayNum - firstDayNum;
            const projectedDayCount = (dayNumDuration > 0) ? (dayNumDuration * futureTimeIndexRatio) : n;

            const extendedMinDay = firstDayNum;
            const extendedMaxDay = firstDayNum + projectedDayCount;

            // Y-Axis Range (with padding)
            const logMinPrice = Math.log10(minPrice);
            const logMaxPrice = Math.log10(maxPrice);
            const logPriceRange = logMaxPrice - logMinPrice;
            const extendedMinPrice = logPriceRange > 0 ? Math.pow(10, logMinPrice - logPriceRange * 0.1) : minPrice * 0.9;
            const extendedMaxPrice = logPriceRange > 0 ? Math.pow(10, logMaxPrice + logPriceRange * 0.4) : maxPrice * 1.4;

            // --- 3. MODEL CALCULATIONS (using *active* priceData) ---
            // NEW: Get last point from *regression* data for price zone
            const lastModelDataPoint = priceData[priceData.length - 1];
            const sortedResiduals = calculateResiduals(priceData, slope, meanIntercept);

            const medianResidual = getPercentile(sortedResiduals, 50);
            const p1Residual = getPercentile(sortedResiduals, 1);
            const p99Residual = getPercentile(sortedResiduals, 99);
            const p20Residual = getPercentile(sortedResiduals, 20);
            const p80Residual = getPercentile(sortedResiduals, 80);

            // Determine current price zone
            const lastLogX = Math.log10(lastModelDataPoint.x);
            const lastLogY = Math.log10(lastModelDataPoint.y);
            const predictedLastLogY = slope * lastLogX + meanIntercept;
            const lastResidual = lastLogY - predictedLastLogY;

            let priceZone = "";
            let priceZoneColor = "";
            if (lastResidual > p80Residual) { priceZone = "Bubble"; priceZoneColor = "bg-red-500"; }
            else if (lastResidual > medianResidual) { priceZone = "Expensive"; priceZoneColor = "bg-yellow-400"; }
            else if (lastResidual > p20Residual) { priceZone = "Value"; priceZoneColor = "bg-green-500"; }
            else { priceZone = "Discount"; priceZoneColor = "bg-blue-300"; }

            priceZoneDiv.innerHTML = `<span class="status-dot ${priceZoneColor}"></span><strong>Rating:</strong>&nbsp;${priceZone}`;
            priceZoneDiv.classList.remove('hidden');

            const medianIntercept = meanIntercept + medianResidual;
            const p1Intercept = meanIntercept + p1Residual;
            const p99Intercept = meanIntercept + p99Residual;
            const p20Intercept = meanIntercept + p20Residual;
            const p80Intercept = meanIntercept + p80Residual;

            // Call projection function (passes full baseData for date calculations)
            calculateProjections(baseData, activeModelParams, projectionTable);

            // --- Update Bottom Status Bar ---
            growthExponentDiv.innerHTML = `<strong>Exponent (α):</strong> ${slope.toFixed(3)}`;
            
            let fitColorClass = "";
            if (rSquared >= 0.9) fitColorClass = "bg-blue-300";
            else if (rSquared >= 0.7) fitColorClass = "bg-green-500";
            else if (rSquared >= 0.5) fitColorClass = "bg-yellow-400";
            else fitColorClass = "bg-red-500";
            
            modelFitDiv.innerHTML = `<span class="status-dot ${fitColorClass}"></span><strong>Fit (R²):</strong> ${rSquared.toFixed(4)}`;
            
            // --- 4. GENERATE CHART DATA ---
            // NEW: Regression lines should start from the beginning of the *model data*
            const startIndex = (selectedModel === 'mleTruncation') ? priceData[0].x : extendedMinDay;
            const endIndex = extendedMaxDay;
            const calculateLinePoints = (intercept) => {
                 const safeStartIndex = Math.max(startIndex, 1); 
                 const safeEndIndex = Math.max(endIndex, 1);
                 return [
                      { x: startIndex, y: Math.pow(10, slope * Math.log10(safeStartIndex) + intercept) },
                      { x: endIndex, y: Math.pow(10, slope * Math.log10(safeEndIndex) + intercept) }
                 ];
            };
            const medianLineData = calculateLinePoints(medianIntercept);
            const p1LineData = calculateLinePoints(p1Intercept);
            const p99LineData = calculateLinePoints(p99Intercept);
            const p20LineData = calculateLinePoints(p20Intercept);
            const p80LineData = calculateLinePoints(p80Intercept);

            const chartPriceDataMap = chartPriceData.map(p => ({ x: p.x, y: p.y }));

            loader.style.display = 'none';

            // --- X-Axis Tick Generation ---
             const xAxisAfterBuildTicks = (axis) => {
                 if (!priceData || priceData.length === 0) return;
                 
                 const newTicks = [];
                 const axisMinDay = axis.min;
                 const axisMaxDay = axis.max;
                 const firstDay = priceData[0];
                 const lastDay = priceData[priceData.length - 1];
                 if (!firstDay || !lastDay) return;

                 // Map day numbers to timestamps
                 const dayRange = lastDay.x - firstDay.x;
                 const timeRange = lastDay.time - firstDay.time;
                 const dayRatio = (dayRange > 0) ? (axisMaxDay - firstDay.x) / dayRange : 0;
                 const estimatedMaxTime = firstDay.time + (dayRatio * timeRange);
                 const minYear = new Date(firstDay.time).getFullYear();
                 const maxYear = !isNaN(estimatedMaxTime) ? new Date(estimatedMaxTime).getFullYear() : minYear;

                 // Find first data point for each year *within the active priceData*
                 let lastYearFound = minYear - 1;
                 for (const p of priceData) {
                     const year = new Date(p.time).getFullYear();
                     if (year > lastYearFound) {
                         if (p.x >= axisMinDay && p.x <= axisMaxDay) {
                             newTicks.push({ value: p.x, label: year.toString() });
                         }
                         lastYearFound = year;
                     }
                 }
                 
                 // Estimate ticks for future projected years
                 const lastDataYear = lastDay ? new Date(lastDay.time).getFullYear() : minYear;
                 if (dayRange > 0 && timeRange > 0 && !isNaN(estimatedMaxTime)) {
                     for (let year = lastDataYear + 1; year <= maxYear; year++) {
                         const yearStartTime = new Date(year, 0, 1).getTime();
                         const timeRatio = (yearStartTime - firstDay.time) / timeRange;
                         
                         // Estimate day number based on the dayRange of the *active* data
                         const estimatedDayNumber = firstDay.x + (timeRatio * dayRange);
                         
                         if (estimatedDayNumber >= axisMinDay && estimatedDayNumber <= axisMaxDay) {
                             newTicks.push({ value: estimatedDayNumber, label: year.toString() });
                         }
                     }
                 }
                 axis.ticks.length = 0; // Clear existing ticks
                 const validTicks = newTicks.filter(tick => !isNaN(tick.value) && tick.label);
                 axis.ticks.push(...validTicks);
             };

            // --- 5. CHART UPDATE OR CREATION ---
            const datasetDefaults = {
                type: 'line', borderWidth: 1, pointRadius: 0, fill: false, pointStyle: 'line'
            };
            const fillDatasetDefaults = {
                type: 'line', pointRadius: 0, borderWidth: 0, pointStyle: 'line', hidden: true,
            };

            if (chart) {
                // --- Update Existing Chart ---
                chart.data.datasets[0].data = chartPriceDataMap;
                chart.data.datasets[1].data = medianLineData;
                chart.data.datasets[2].data = p1LineData;
                chart.data.datasets[3].data = p99LineData;

                const datasetsToUpdate = [
                    { index: 4, label: '20th Pctl', data: p20LineData, style: grayLineStyle, hidden: true },
                    { index: 5, label: '50th Pctl (Hidden)', data: medianLineData, style: grayLineStyle, hidden: true },
                    { index: 6, label: '80th Pctl', data: p80LineData, style: grayLineStyle, hidden: true },
                    { index: 7, label: 'Discount Band (P1-P20)', data: p20LineData, fill: 2, backgroundColor: blueFillColor, hidden: true },
                    { index: 8, label: 'Value Band (P20-P50)', data: medianLineData, fill: 4, backgroundColor: greenFillColor, hidden: true },
                    { index: 9, label: 'Expensive Band (P50-P80)', data: p80LineData, fill: 1, backgroundColor: yellowFillColor, hidden: true },
                    { index: 10, label: 'Bubble Band (P80-P99)', data: p99LineData, fill: 6, backgroundColor: redFillColor, hidden: true },
                ];

                datasetsToUpdate.forEach(dsInfo => {
                    if (chart.data.datasets[dsInfo.index]) {
                        Object.assign(chart.data.datasets[dsInfo.index], {
                            data: dsInfo.data, label: dsInfo.label, ...(dsInfo.style || {}),
                            ...(dsInfo.fill !== undefined && { fill: dsInfo.fill, backgroundColor: dsInfo.backgroundColor }),
                            hidden: dsInfo.index === 5 ? true : dsInfo.hidden,
                        });
                    } else {
                         chart.data.datasets.push({
                             ...datasetDefaults, ...(dsInfo.style || {}),
                             ...(dsInfo.fill !== undefined ? fillDatasetDefaults : {}),
                             label: dsInfo.label, data: dsInfo.data,
                             hidden: dsInfo.index === 5 ? true : dsInfo.hidden,
                             ...(dsInfo.fill !== undefined && { fill: dsInfo.fill, backgroundColor: dsInfo.backgroundColor }),
                         });
                    }
                });

                 applyBandVisibility(showBandsCheckbox.checked);

                chart.options.scales.x.min = extendedMinDay;
                chart.options.scales.x.max = extendedMaxDay;
                chart.options.scales.y.min = extendedMinPrice;
                chart.options.scales.y.max = extendedMaxPrice;
                chart.options.scales.x.afterBuildTicks = xAxisAfterBuildTicks;
                chart.update();

            } else {
                // --- Create New Chart ---
                chart = new Chart(ctx, {
                    data: {
                        datasets: [
                            { ...datasetDefaults, type: 'line', label: 'TAO Price', data: chartPriceDataMap, backgroundColor: 'rgba(0, 0, 0, 0.05)', borderColor: 'rgba(0, 0, 0, 1)', borderWidth: 2, pointHoverRadius: 5, tension: 0.1 },
                            { ...datasetDefaults, label: '50th Percentile', data: medianLineData, ...orangeLineStyle, hidden: false },
                            { ...datasetDefaults, ...grayLineStyle, label: '1st Pctl', data: p1LineData },
                            { ...datasetDefaults, ...grayLineStyle, label: '99th Pctl', data: p99LineData },
                            { ...datasetDefaults, ...grayLineStyle, label: '20th Pctl', data: p20LineData, hidden: true },
                            { ...datasetDefaults, ...grayLineStyle, label: '50th Pctl (Hidden)', data: medianLineData, hidden: true },
                            { ...datasetDefaults, ...grayLineStyle, label: '80th Pctl', data: p80LineData, hidden: true },
                            { ...fillDatasetDefaults, label: 'Discount Band (P1-P20)', data: p20LineData, fill: 2, backgroundColor: blueFillColor },
                            { ...fillDatasetDefaults, label: 'Value Band (P20-P50)', data: medianLineData, fill: 4, backgroundColor: greenFillColor },
                            { ...fillDatasetDefaults, label: 'Expensive Band (P50-P80)', data: p80LineData, fill: 1, backgroundColor: yellowFillColor },
                            { ...fillDatasetDefaults, label: 'Bubble Band (P80-P99)', data: p99LineData, fill: 6, backgroundColor: redFillColor },
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#374151', usePointStyle: true, boxWidth: 30, boxHeight: 12,
                                    filter: (item) => !item.text.includes('Band') && item.datasetIndex !== 5,
                                }
                            },
                            tooltip: {
                                callbacks: {
                                     title: (tooltipItems) => {
                                         if (tooltipItems.length > 0) {
                                             const item = tooltipItems[0];
                                             const dayNumber = item.parsed.x; // This is the x-value on the chart
                                             
                                             // Find the corresponding data point in the *original* baseData
                                             // This requires converting the x-value back to a dayIndex
                                             const { modelType, activeDayOffset } = activeModelParams;
                                             let targetDayIndex;
                                             if (modelType === 'mleTruncation') {
                                                targetDayIndex = dayNumber;
                                             } else {
                                                targetDayIndex = dayNumber - activeDayOffset;
                                             }
                                             
                                             // Find the *closest* point in baseData by dayIndex
                                             // This will work for both price points and line points
                                             // Use a linear search on baseData, it's already sorted by dayIndex
                                             let dataPoint = baseData.find(p => p.dayIndex === Math.round(targetDayIndex));
                                             
                                             if (!dataPoint) {
                                                // Fallback for projected points: find closest
                                                dataPoint = baseData.reduce((prev, curr) => {
                                                    return (Math.abs(curr.dayIndex - targetDayIndex) < Math.abs(prev.dayIndex - targetDayIndex) ? curr : prev);
                                                });
                                             }

                                             if (dataPoint) {
                                                 const date = new Date(dataPoint.time);
                                                 return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
                                             }

                                             // Fallback (should rarely be hit)
                                             return `Day ~${targetDayIndex.toFixed(0)}`;
                                         }
                                         return '';
                                     },
                                     label: (context) => {
                                         if (context.dataset.label.includes('Band') || context.datasetIndex === 5) return null;
                                         return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                                     }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic', min: extendedMinDay, max: extendedMaxDay,
                                title: { display: true, text: `Time (Log Scale)`, color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563', autoSkip: false,
                                    callback: function(value) {
                                        const tick = this.getTicks().find(t => t.value === value);
                                        return tick ? tick.label : null;
                                    }
                                },
                                afterBuildTicks: xAxisAfterBuildTicks, 
                                grid: { color: 'rgba(0, 0, 0, 0.1)' }
                            },
                            y: {
                                type: 'logarithmic', min: extendedMinPrice, max: extendedMaxPrice,
                                title: { display: true, text: 'Price (Log Scale)', color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563',
                                    callback: function(value, index, ticks) {
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return `$${value.toLocaleString()}`;
                                        }
                                        return ''; 
                                    }
                                },
                                grid: { 
                                    color: function(context) {
                                        const value = context.tick.value;
                                        if (value <= 0) return 'rgba(0, 0, 0, 0.1)'; 
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return 'rgba(0, 0, 0, 0.1)'; 
                                        } else {
                                            return 'rgba(0, 0, 0, 0.05)';
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // --- 6. FINAL EVENT LISTENERS ---
            showBandsContainer.classList.remove('hidden');
            showBandsCheckbox.removeEventListener('change', handleBandToggle);
            showBandsCheckbox.addEventListener('change', handleBandToggle);

            modelSelect.removeEventListener('change', createOrUpdateChart);
            modelSelect.addEventListener('change', createOrUpdateChart);

            applyBandVisibility(showBandsCheckbox.checked);
            if(chart) chart.update('none'); 
        }

        /**
         * Event handler for the "Show Bands" checkbox.
         */
        function handleBandToggle() {
             if (!chart) return;
             applyBandVisibility(showBandsCheckbox.checked);
             chart.update();
        }

        /**
         * Toggles visibility and styles for band datasets.
         */
        function applyBandVisibility(showBands) {
             if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length < 11) {
                 console.error("Chart or datasets not fully initialized for applyBandVisibility.");
                 return;
             }
             const mainMedianIndex = 1;
             const p1Index = 2; const p99Index = 3;
             const p20Index = 4; const redundantP50Index = 5; const p80Index = 6;
             const fillIndices = [7, 8, 9, 10];

             if (chart.data.datasets[0]) chart.setDatasetVisibility(0, true); // Price
             if (chart.data.datasets[mainMedianIndex]) chart.setDatasetVisibility(mainMedianIndex, true);
             if (chart.data.datasets[redundantP50Index]) chart.setDatasetVisibility(redundantP50Index, false); // Always hidden

             if (showBands) {
                 const styleToApply = grayFineLineStyle;
                 if (chart.data.datasets[p1Index]) { chart.setDatasetVisibility(p1Index, true); Object.assign(chart.data.datasets[p1Index], styleToApply); }
                 if (chart.data.datasets[p99Index]) { chart.setDatasetVisibility(p99Index, true); Object.assign(chart.data.datasets[p99Index], styleToApply); }
                 if (chart.data.datasets[p20Index]) { chart.setDatasetVisibility(p20Index, true); Object.assign(chart.data.datasets[p20Index], styleToApply); }
                 if (chart.data.datasets[p80Index]) { chart.setDatasetVisibility(p80Index, true); Object.assign(chart.data.datasets[p80Index], styleToApply); }
                 
                 fillIndices.forEach(index => { if (chart.data.datasets[index]) chart.setDatasetVisibility(index, true); });
                 const medianDataset = chart.data.datasets[mainMedianIndex];
                 if (medianDataset) Object.assign(medianDataset, grayFineLineStyle);

             } else {
                 const styleToApply = grayDashedLineStyle; 
                 if (chart.data.datasets[p1Index]) { chart.setDatasetVisibility(p1Index, true); Object.assign(chart.data.datasets[p1Index], styleToApply); }
                 if (chart.data.datasets[p99Index]) { chart.setDatasetVisibility(p99Index, true); Object.assign(chart.data.datasets[p99Index], styleToApply); }
                 if (chart.data.datasets[p20Index]) { chart.setDatasetVisibility(p20Index, false); Object.assign(chart.data.datasets[p20Index], styleToApply); }
                 if (chart.data.datasets[p80Index]) { chart.setDatasetVisibility(p80Index, false); Object.assign(chart.data.datasets[p80Index], styleToApply); }

                 fillIndices.forEach(index => { if (chart.data.datasets[index]) chart.setDatasetVisibility(index, false); });
                 const medianDataset = chart.data.datasets[mainMedianIndex];
                 if (medianDataset) Object.assign(medianDataset, orangeLineStyle);
             }
        }

        /**
         * Calculates R-squared (coefficient of determination) for the log-log regression.
         */
        function calculateRSquared(data, slope, intercept) {
            let ss_tot = 0, ss_res = 0, y_mean = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length < 2) return 0;

            validData.forEach(p => y_mean += Math.log10(p.y));
            y_mean /= validData.length;

            validData.forEach(p => {
                const logY = Math.log10(p.y);
                const logX = Math.log10(p.x);
                const predictedLogY = slope * logX + intercept;
                ss_tot += Math.pow(logY - y_mean, 2);
                ss_res += Math.pow(logY - predictedLogY, 2);
            });
             return ss_tot === 0 ? 1 : Math.max(0, 1 - (ss_res / ss_tot)); 
        }

        /**
         * Calculates and displays future price projections in the floating table.
         * This function now relies on the global activeModelParams.
         */
        function calculateProjections(baseData, modelParams, tableElement) {
            if (!baseData || baseData.length === 0 || !tableElement || !modelParams) {
                if(tableElement) tableElement.classList.add('hidden');
                return;
            }

            const { slope, meanIntercept, modelType, activeDayOffset, truncationStartIndex } = modelParams;

            // 1. Get the reference date and dayIndex from the *first data point* in the full dataset
            const firstDataPointDate = new Date(baseData[0].time);
            const firstDayIndex = baseData[0].dayIndex; // e.g., 1
            
            // 2. Define target dates dynamically
            const today = new Date();
            const currentYear = today.getFullYear();
            const targetDates = [
                { label: "Today", date: today },
                { label: `${currentYear + 1}`, date: new Date(currentYear + 1, 0, 1) },
                { label: `${currentYear + 2}`, date: new Date(currentYear + 2, 0, 1) },
                { label: `${currentYear + 3}`, date: new Date(currentYear + 3, 0, 1) }
            ];

            const MS_PER_DAY = 1000 * 60 * 60 * 24;

            // 3. Helper function to get the target dayIndex (relative to the first day in data)
            const getDayIndex = (targetDate) => {
                const diffTime = targetDate.getTime() - firstDataPointDate.getTime();
                const diffDays = Math.round(diffTime / MS_PER_DAY);
                return firstDayIndex + diffDays;
            };

            // 4. Helper function to calculate price using the active model's formula
            const calculatePrice = (targetDayIndex) => {
                let dayForLog;
                if (modelType === 'mleTruncation') {
                    // For truncation, we just use the dayIndex.
                    // We must also check if this day is *before* our model's start.
                    const modelStartDay = baseData[truncationStartIndex].dayIndex;
                    if (targetDayIndex < modelStartDay) return NaN; // Date is before model starts
                    dayForLog = targetDayIndex;
                } else {
                    // For offset models, we add the offset
                    dayForLog = targetDayIndex + activeDayOffset;
                }

                if (dayForLog <= 0) return NaN; // Can't log(0) or negative
                const logX = Math.log10(dayForLog);
                return Math.pow(10, slope * logX + meanIntercept);
            };

            // 5. Build HTML
            let tableHtml = `
                <h3>
                    <span>Fair Value</span>
                    <button onclick="document.getElementById('projectionTable').style.display='none'" type="button" title="Close">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </h3>`;

            // 6. Calculate and build HTML for each price
            targetDates.forEach(item => {
                const targetDayIndex = getDayIndex(item.date); // e.g., 800
                const projectedPrice = calculatePrice(targetDayIndex);
                
                const priceString = isNaN(projectedPrice) ? "N/A" : `$${projectedPrice.toFixed(2)}`;
                const label = item.label;

                tableHtml += `
                    <div>
                        <span>${label}</span>
                        <span>${priceString}</span>
                    </div>
                `;
            });

            tableElement.innerHTML = tableHtml;
            tableElement.style.display = ''; 
            tableElement.classList.remove('hidden');
        }

        // --- FULLSCREEN & MOBILE VIEW LOGIC ---

        const mainContainer = document.getElementById('mainContainer');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fsIconEnter = document.getElementById('fsIconEnter');
        const fsIconExit = document.getElementById('fsIconExit');
        const headerElement = document.querySelector('header');
        const bottomBarElement = document.getElementById('bottomModelBar');
        const topBarElement = document.getElementById('topStatusBar');
        const chartCardElement = document.getElementById('chartCard');

        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (mainContainer.requestFullscreen) mainContainer.requestFullscreen().catch(err => console.error(`Error entering fullscreen: ${err.message}`));
                else if (mainContainer.webkitRequestFullscreen) mainContainer.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen().catch(err => console.error(`Error exiting fullscreen: ${err.message}`));
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        function handleFullscreenChange() {
             requestAnimationFrame(() => { 
                 const isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                 const isMobile = window.innerWidth < 640;
                 const isLandscape = screen.orientation ? screen.orientation.type.includes('landscape') : window.innerWidth > window.innerHeight;

                 if (isInFullscreen) {
                     fsIconEnter.classList.add('hidden');
                     fsIconExit.classList.remove('hidden');
                     fullscreenBtn.setAttribute('title', 'Exit Fullscreen');
                 } else {
                     fsIconEnter.classList.remove('hidden');
                     fsIconExit.classList.add('hidden');
                     fullscreenBtn.setAttribute('title', 'Enter Fullscreen');
                 }

                 if (headerElement) headerElement.style.display = '';
                 if (bottomBarElement) bottomBarElement.style.display = '';
                 if (topBarElement) topBarElement.style.display = '';
                 if (chartCardElement) chartCardElement.style.padding = '';

                 if (isInFullscreen && isMobile && isLandscape) {
                     if (headerElement) headerElement.style.display = 'none';
                     if (bottomBarElement) bottomBarElement.style.display = 'none';
                     if (chartCardElement) chartCardElement.style.padding = '0';
                 }

                  if (chart) {
                     setTimeout(() => {
                         requestAnimationFrame(() => {
                             if (chart) chart.resize();
                         });
                     }, 50); 
                  }
             });
        }

        // --- Event Listeners ---
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange); // Safari
        window.addEventListener('resize', handleFullscreenChange);
         if (screen.orientation) {
             screen.orientation.addEventListener('change', handleFullscreenChange);
         } else {
             window.addEventListener('orientationchange', handleFullscreenChange); // Older mobile
         }

        // Initial load
        window.onload = () => {
            createOrUpdateChart();
            // Add listener for model selection
            modelSelect.addEventListener('change', createOrUpdateChart);
            setTimeout(handleFullscreenChange, 150); // Initial check for mobile state
        }
    </script>

</body>
</html>

