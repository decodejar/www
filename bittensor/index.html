<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAO Tensor Law Model</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ff6d00; /* Orange */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
    /* When body has a child in fullscreen, stop centering it */
        body:has(#mainContainer:fullscreen) {
            display: block; /* Override body's flex and items-center */
        }

        /* When the main container goes fullscreen... */
        #mainContainer:fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none !important; /* Override max-w-6xl */
            border-radius: 0 !important; /* Override rounded-2xl */

            /* Use flex to manage the inner layout */
            display: flex;
            flex-direction: column;
        }

        /* Make the chart's parent card grow to fill the space */
        #mainContainer:fullscreen #chartCard {
            flex-grow: 1; /* This card will expand */
            display: flex;
            flex-direction: column;
        }

        /* Make the chart's wrapper (with the fixed height) grow */
        #mainContainer:fullscreen #chartWrapper {
            /* Override the h-[40rem] class and make it grow */
            height: 100% !important;
            flex-grow: 1;
        }

        /* Hide the footer when fullscreen */
        body:has(#mainContainer:fullscreen) footer {
            display: none;
        }

        /* --- Mobile Fullscreen Optimizations --- */

        /* CSS only handles the PORTRAIT overlay now */
        @media (max-width: 639px) and (orientation: portrait) {
            #mainContainer:fullscreen #rotateOverlay {
                display: flex !important; /* Show the overlay */
            }

            #mainContainer:fullscreen header,
            #mainContainer:fullscreen #topStatusBar,
            #mainContainer:fullscreen #chartCard,
            #mainContainer:fullscreen #bottomModelBar,
            #mainContainer:fullscreen #fullscreenBtn {
                display: none !important; /* Hide everything else */
            }
        }

        /* Style applied by JS for mobile landscape */
        #mainContainer.mobile-fullscreen-landscape header,
        #mainContainer.mobile-fullscreen-landscape #bottomModelBar {
             display: none !important;
        }
         #mainContainer.mobile-fullscreen-landscape #chartCard {
             padding: 0 !important;
         }
         #mainContainer.mobile-fullscreen-landscape #topStatusBar {
              display: flex !important; /* Ensure it remains visible */
         }


        /* --- END: Mobile Fullscreen Optimizations --- */
    </style>
</head>
<!--
    FIX: Changed min-h-screen to h-screen.
    This makes the body's height match the viewport exactly,
    allowing it to shrink and fixing the vertical scaling bug.
-->
<!-- MODIFIED: Further reduced body padding -->
<body class="bg-gray-100 text-gray-800 flex flex-col items-center h-screen p-2">

    <!--
        This container has all scaling rules:
        - flex-grow: Grow to fill the body
        - max-w-[1600px]: Max width
        - max-h-[900px]: Max height
        - min-h-[30rem]: Min height
    -->
    <!-- MODIFIED: Further reduced container padding -->
    <div id="mainContainer" class="w-full flex-grow max-w-[1920px] max-h-[1080px] min-h-[30rem] flex flex-col bg-white rounded-lg shadow-xl p-2 sm:p-3 md:p-4 relative">

        <!-- *** NEW "Please Rotate" Overlay *** -->
        <div id="rotateOverlay" class="hidden absolute inset-0 w-full h-full bg-white/95 z-50 flex-col items-center justify-center text-center p-8">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 text-gray-600 mb-4 animate-pulse">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.992 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
            <h2 class="text-2xl font-semibold text-gray-800 mb-2">Please Rotate Your Device</h2>
            <p class="text-gray-600">This chart is best viewed in landscape mode.</p>
        </div>
        <!-- *** END Overlay *** -->

        <button id="fullscreenBtn" onclick="toggleFullScreen()" class="absolute top-4 right-4 sm:top-6 sm:right-6 text-gray-400 hover:text-gray-800 transition-colors z-20 p-1 rounded-full hover:bg-gray-100" title="Toggle Fullscreen">
            <svg id="fsIconEnter" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m4.5 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
            </svg>
            <svg id="fsIconExit" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 hidden">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 9L3.75 3.75M9 9h4.5m-4.5 0v4.5m0-4.5L3.75 3.75M9 15l-5.25 5.25M9 15h4.5m-4.5 0v-4.5m0 4.5l-5.25 5.25M15 9l5.25-5.25M15 9h-4.5m4.5 0v4.5m0-4.5l5.25-5.25M15 15l5.25 5.25M15 15h-4.5m4.5 0v-4.5m0 4.5l5.25 5.25" />
            </svg>
        </button>
        <!-- MODIFIED: Reduced bottom margin, title font size -->
        <header class="text-center mb-3">
            <h1 class="text-xl sm:text-2xl md:text-3xl text-gray-900">TAO Tensor Law Model</h1>
            <!-- REMOVED: Subtitle paragraph -->
        </header>

        <!-- *** MOVED STATUS BAR HERE *** -->
        <!-- *** MODIFIED: Added px-4 to match the inner padding of mainContainer and removed explicit width class*** -->
        <!-- MODIFIED: Further reduced padding and bottom margin -->
        <div id="topStatusBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mb-2 text-sm text-gray-600 px-4">
             <div id="statusDiv" class="flex items-center">
                 <span class="status-dot bg-yellow-500"></span>Loading latest data...
             </div>
             <div id="lastUpdateDiv" class="hidden sm:block">
                 <!-- Placeholder for last update time -->
             </div>
              <div id="lastPriceDiv" class="hidden sm:block">
                 <!-- Placeholder for last price -->
             </div>
             <!-- *** NEW Price Zone Div *** -->
             <div id="priceZoneDiv" class="flex items-center hidden sm:block">
                <!-- Content injected by JS -->
             </div>
             <!-- *** END NEW Div *** -->
             <!-- *** NEW Show Bands Checkbox *** -->
             <div id="showBandsContainer" class="flex items-center hidden"> <!-- Initially hidden -->
                 <input type="checkbox" id="showBandsCheckbox" class="mr-1.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                 <label for="showBandsCheckbox" class="cursor-pointer mr-1">Bands&nbsp;</label> <!-- Added right margin -->
                 <!-- MODIFICATION: Added tooltip span for bands -->
                 <span title="Blue: Discount (P1-P20), Green: Value (P20-P50), Yellow: Expensive (P50-P80), Red: Bubble (P80-P99)" class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
             </div>
             <!-- *** END Checkbox *** -->
        </div>

        <!--
            Chart Container
            - flex-grow: Fills the main container
            - min-h-0: Fixes the vertical scaling bug by allowing this to shrink
        -->
        <!-- MODIFIED: Further reduced padding -->
        <div id="chartCard" class="bg-white p-2 rounded-lg relative flex-grow flex flex-col min-h-0">
            <div id="loader" class="absolute inset-0 bg-white/80 flex items-center justify-center z-10">
                <div class="loader"></div>
            </div>
            <!--
                Chart Wrapper
                - flex-grow: Fills the chart card
                - min-h-0: Fixes the vertical scaling bug by allowing this to shrink
            -->
            <div id="chartWrapper" class="relative flex-grow min-h-0">
                <canvas id="powerLawChart"></canvas>
            </div>

            <!-- *** CONSOLIDATED MODEL INFO BAR *** -->
            <!-- This bar now holds the model info and status, styled like the top bar -->
            <!-- *** MODIFIED: Removed explicit width class*** -->
            <!-- MODIFIED: Further reduced padding and top margin -->
            <div id="bottomModelBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mt-2 text-sm text-gray-600">
                <!-- NEW: Split modelInfo into separate divs for single-row layout -->
                <div id="growthExponentDiv"></div>
                <div id="modelFitDiv"></div>
                <!-- *** NEW: Optimal Offset Div *** -->
                <div id="optimalOffsetDiv"></div>
                <!-- *** END: Optimal Offset Div *** -->

                <!-- powerLawStatusDiv: content injected by JS -->
                <!-- Added flex items-center to align the status dot -->
                <!-- MODIFIED: Added structure for tooltip -->
                <div id="powerLawStatusDiv" class="flex items-center">
                     <span id="powerLawStatusDot" class="status-dot bg-yellow-500"></span> <!-- Dot needs ID for JS -->
                     <span id="powerLawStatusText">Power Law&nbsp;</span> <!-- Text needs ID for JS -->
                     <!-- MODIFIED: Changed text/border color to gray-600 and hover bg to gray-300 -->
                     <span title="Green indicates a strong model fit (R² >= 0.9)" class="ml-1 text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
                </div>
                <!-- *** END MODIFICATION *** -->
            </div>
            <!-- *** END CONSOLIDATED BAR *** -->
        </div>

    </div>

    <!-- MODIFIED: Further reduced padding and top margin -->
    <footer class="text-center p-1 mt-2">
        <!-- ADDED Disclaimer -->
        <p class="text-gray-600 text-xs mt-1 mb-4">Disclaimer: This tool is for informational and research purposes only and does not constitute financial or trading advice. Past performance is not indicative of future results.</p>
        <p class="text-gray-600 text-sm">&copy; 2025 DecodeJar |&nbsp;<a href="https://x.com/decodejar" target="_blank" rel="noopener noreferrer" class="hover:text-indigo-500 transition-colors">https://x.com/decodejar</a></p>
        <!-- END ADDITION -->
    </footer>

<script>
        /*
        * TAO Tensor Law Model & Regression Logic
        * Copyright (c) 2025 DecodeJar | https://x.com/decodejar. All Rights Reserved.
        * Unauthorized copying or distribution is prohibited.
        */

        const growthExponentDiv = document.getElementById('growthExponentDiv');
        const modelFitDiv = document.getElementById('modelFitDiv');
        const loader = document.getElementById('loader');
        const statusDiv = document.getElementById('statusDiv');
        const lastUpdateDiv = document.getElementById('lastUpdateDiv');
        const lastPriceDiv = document.getElementById('lastPriceDiv');
        const powerLawStatusDiv = document.getElementById('powerLawStatusDiv');
        const powerLawStatusDot = document.getElementById('powerLawStatusDot');
        const powerLawStatusText = document.getElementById('powerLawStatusText');
        const priceZoneDiv = document.getElementById('priceZoneDiv');
        const ctx = document.getElementById('powerLawChart').getContext('2d');
        // --- NEW: Optimal Offset Ref ---
        const optimalOffsetDiv = document.getElementById('optimalOffsetDiv');
        // --- NEW: Checkbox References ---
        const showBandsContainer = document.getElementById('showBandsContainer');
        const showBandsCheckbox = document.getElementById('showBandsCheckbox');
        // --- END ---

        const DAY_OFFSET = 81; // Makes log scale spacing more gradual.
        let chart;

        // --- NEW: Define Fill Colors ---
        const blueFillColor = 'rgba(147, 197, 253, 0.1)'; // approx blue-300
        const greenFillColor = 'rgba(34, 197, 94, 0.1)'; // approx green-500
        const yellowFillColor = 'rgba(250, 204, 21, 0.1)'; // approx yellow-400
        const redFillColor = 'rgba(239, 68, 68, 0.1)'; // approx red-500
        // --- END ---

        // --- NEW: Define Line Styles ---
        const grayLineStyle = {
            borderColor: 'rgba(156, 163, 175, 0.7)', // Light gray
            borderWidth: 1,
        };
        const orangeLineStyle = {
            borderColor: '#ff6d00', // Orange
            borderWidth: 2,
        };
        // --- END ---

        async function loadPriceData() {
            try {
                // Add cache-busting query parameter
                const response = await fetch(`./price_data.json?t=${new Date().getTime()}`);
                if (!response.ok) {
                    throw new Error(`Failed to load data file: ${response.statusText}`);
                }
                const data = await response.json();
                 if (!Array.isArray(data)) {
                         throw new Error("Invalid data format in JSON file");
                 }
                // Filter out any data points with a price of 0 or less, as they break the log scale.
                // MODIFICATION: Return 'dayIndex' (i+1) without the offset. Offset is applied later.
                return data.map((p, i) => ({ time: p[0] * 1000, dayIndex: i + 1, y: p[1] })).filter(p => p.y > 0);
            } catch (error) {
                console.error("Error loading price data:", error);
                statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>Error loading data. Check console.`;
                loader.style.display = 'none';
                return null; // Return null on error
            }
        }

        function linearRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            const n = validData.length;
            if (n < 2) return { slope: 0, intercept: 0 };
            for (const { x, y } of validData) {
                const logX = Math.log10(x);
                const logY = Math.log10(y);
                sumX += logX; sumY += logY; sumXY += logX * logY; sumX2 += logX * logX;
            }
            const denominator = (n * sumX2 - sumX * sumX);
            if (denominator === 0) return { slope: 0, intercept: 0 };
            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept };
        }

        // Calculates the residuals (logY - predictedLogY)
        function calculateResiduals(data, slope, intercept) {
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length === 0) return [];
            return validData.map(p => {
                const logX = Math.log10(p.x); // x already includes offset
                const logY = Math.log10(p.y);
                const predictedLogY = slope * logX + intercept;
                return logY - predictedLogY;
            }).sort((a, b) => a - b); // Sort residuals for percentile calculation
        }

        // Calculates a specific percentile from a sorted list of residuals
        function getPercentile(sortedResiduals, percentile) {
            if (!sortedResiduals || sortedResiduals.length === 0) return 0;
            const index = (percentile / 100) * (sortedResiduals.length - 1);
            const lowerIndex = Math.floor(index);
            const upperIndex = Math.ceil(index);
            if (lowerIndex === upperIndex) {
                 return sortedResiduals[lowerIndex];
            } else {
                 // Linear interpolation
                 const weight = index - lowerIndex;
                 return sortedResiduals[lowerIndex] * (1 - weight) + sortedResiduals[upperIndex] * weight;
            }
        }

        // --- NEW: Function to find the optimal DAY_OFFSET for R² ---
        // --- MODIFIED: Removed default maxOffset, it's now passed from createOrUpdateChart ---
        function findOptimalOffset(baseData, minOffset = 1, maxOffset) {
            let bestOffset = -1;
            let bestRSquared = -Infinity;

            // Need at least 2 data points to calculate regression
            if (baseData.length < 2) {
                return { optimalOffset: -1, bestFit: 0 };
            }

            // --- NEW: Check if maxOffset was provided ---
            if (typeof maxOffset === 'undefined' || maxOffset < minOffset) {
                console.error("findOptimalOffset called without a valid maxOffset.");
                // Fallback, though it should be passed from createOrUpdateChart
                maxOffset = baseData.length; 
            }

            for (let offset = minOffset; offset <= maxOffset; offset++) {
                // 1. Apply the current test offset
                // We only need x and y for the regression functions
                const offsetData = baseData.map(p => ({
                    x: p.dayIndex + offset,
                    y: p.y
                }));

                // 2. Run regression for this offset
                const { slope, intercept } = linearRegression(offsetData);
                
                // linearRegression returns {0, 0} on failure (e.g., < 2 points)
                if (slope === 0 && intercept === 0 && offsetData.length > 1) {
                    continue; // Skip if regression failed
                }

                // 3. Calculate R²
                const rSquared = calculateRSquared(offsetData, slope, intercept);

                // 4. Track the best fit
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestOffset = offset;
                }
            }
            return { optimalOffset: bestOffset, bestFit: bestRSquared };
        }
        // --- END NEW FUNCTION ---

        async function createOrUpdateChart() {
            loader.style.display = 'flex';

            // 1. Load BASE data (no offset applied yet)
            const baseData = await loadPriceData();

            if (!baseData || baseData.length === 0) {
                 if (!statusDiv.innerHTML.includes('Error')) {
                      statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>No valid data to display.`;
                 }
// ... existing code ... -->
                 showBandsContainer.classList.add('hidden'); // Hide checkbox if no data
                 loader.style.display = 'none';
                 return;
            }

            // 2. --- NEW: Run optimization function on BASE data ---
            // This searches for the best offset
            // --- MODIFIED: Pass baseData.length as the maxOffset ---
            const maxDaysInData = baseData.length > 0 ? baseData.length : 730; // Use data length, fallback to 730 if empty (though already handled)
            const { optimalOffset, bestFit } = findOptimalOffset(baseData, 1, maxDaysInData);
            
            // 3. --- NEW: Apply the HARD-CODED offset for the chart ---
            // All subsequent calculations for drawing the chart will use this `priceData`
            const priceData = baseData.map(p => ({ ...p, x: p.dayIndex + DAY_OFFSET }));


            const lastDataPoint = priceData[priceData.length - 1];
            const lastPrice = lastDataPoint.y;
            const lastTimestamp = lastDataPoint.time;
            const lastUpdateDate = new Date(lastTimestamp).toLocaleDateString(undefined, {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            statusDiv.innerHTML = `<span class="status-dot bg-green-500"></span>Data Loaded`;
            lastUpdateDiv.innerHTML = `<strong>Updated:</strong> ${lastUpdateDate}`;
            lastPriceDiv.innerHTML = `<strong>Price:</strong> $${lastPrice.toFixed(2)}`;
            lastUpdateDiv.classList.remove('hidden');
            lastPriceDiv.classList.remove('hidden');

            const times = priceData.map(p => p.time);
            const prices = priceData.map(p => p.y);
            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);

            // X-Axis Range Calculation
            const n = priceData.length;
            const firstDayNum = priceData[0].x;
            const timeDuration = maxTime - minTime;
            const extendedMaxTime = maxTime + (timeDuration * 1); // 100% projection
            const futureTimeIndexRatio = (timeDuration > 0) ? (extendedMaxTime - minTime) / timeDuration : 1;
            const projectedDayCount = n * futureTimeIndexRatio;
            const extendedMinDay = firstDayNum;
            const extendedMaxDay = firstDayNum + projectedDayCount - 1;

            // Y-Axis Range Calculation
            const logMinPrice = Math.log10(minPrice);
            const logMaxPrice = Math.log10(maxPrice);
            const logPriceRange = logMaxPrice - logMinPrice;
            const extendedMinPrice = logPriceRange > 0 ? Math.pow(10, logMinPrice - logPriceRange * 0.1) : minPrice * 0.9;
            const extendedMaxPrice = logPriceRange > 0 ? Math.pow(10, logMaxPrice + logPriceRange * 0.4) : maxPrice * 1.4;

            // --- Calculations ---
            const { slope, intercept: meanIntercept } = linearRegression(priceData);
            const sortedResiduals = calculateResiduals(priceData, slope, meanIntercept);

            const medianResidual = getPercentile(sortedResiduals, 50);
            const p1Residual = getPercentile(sortedResiduals, 1);
            const p99Residual = getPercentile(sortedResiduals, 99);
            const p20Residual = getPercentile(sortedResiduals, 20);
            const p80Residual = getPercentile(sortedResiduals, 80);

            const lastLogX = Math.log10(lastDataPoint.x);
            const lastLogY = Math.log10(lastDataPoint.y);
            const predictedLastLogY = slope * lastLogX + meanIntercept;
            const lastResidual = lastLogY - predictedLastLogY;

            let priceZone = "";
            let priceZoneColor = "";
            if (lastResidual > p80Residual) { priceZone = "Bubble"; priceZoneColor = "bg-red-500"; }
            else if (lastResidual > medianResidual) { priceZone = "Expensive"; priceZoneColor = "bg-yellow-400"; }
            else if (lastResidual > p20Residual) { priceZone = "Value"; priceZoneColor = "bg-green-500"; }
            else { priceZone = "Discount"; priceZoneColor = "bg-blue-300"; }

            priceZoneDiv.innerHTML = `<span class="status-dot ${priceZoneColor}"></span><strong>Price Band:</strong>&nbsp;${priceZone}`;
            priceZoneDiv.classList.remove('hidden');

            // --- Calculate All Intercepts ---
            const medianIntercept = meanIntercept + medianResidual; // Shifted 50th
            const p1Intercept = meanIntercept + p1Residual;
            const p99Intercept = meanIntercept + p99Residual;
            const p20Intercept = meanIntercept + p20Residual; // NEW
            const p80Intercept = meanIntercept + p80Residual; // NEW

            const rSquared = calculateRSquared(priceData, slope, meanIntercept);
            const modelFitGood = rSquared >= 0.9;

            powerLawStatusDiv.style.display = 'flex';
            if (powerLawStatusDot) {
                 powerLawStatusDot.className = `status-dot ${modelFitGood ? 'bg-green-500' : 'bg-red-500'}`;
            }

            growthExponentDiv.innerHTML = `<strong>Growth Exponent (α):</strong> ${slope.toFixed(3)}`;
            modelFitDiv.innerHTML = `<strong>Model Fit (R²):</strong> ${rSquared.toFixed(4)}`;
            
            // --- NEW: Display the optimal offset results ---
            optimalOffsetDiv.innerHTML = `<strong>Offset:</strong> ${DAY_OFFSET} | <strong>Optimal:</strong> ${optimalOffset} (R²: ${bestFit.toFixed(4)})`;

            // --- Calculate All Line Data Points ---
            const startIndex = extendedMinDay;
            const endIndex = extendedMaxDay;
            const calculateLinePoints = (intercept) => {
                 const safeStartIndex = Math.max(startIndex, 1);
                 const safeEndIndex = Math.max(endIndex, 1);
                 return [
                      { x: startIndex, y: Math.pow(10, slope * Math.log10(safeStartIndex) + intercept) },
                      { x: endIndex, y: Math.pow(10, slope * Math.log10(safeEndIndex) + intercept) }
                 ];
            };
            const medianLineData = calculateLinePoints(medianIntercept); // For 50th pctl line (orange OR gray)
            const p1LineData = calculateLinePoints(p1Intercept);
            const p99LineData = calculateLinePoints(p99Intercept);
            const p20LineData = calculateLinePoints(p20Intercept);
            const p80LineData = calculateLinePoints(p80Intercept);

            const chartPriceData = priceData.map(p => ({ x: p.x, y: p.y }));

            loader.style.display = 'none';

            // --- X-Axis Tick Builder --- (No changes needed here)
             const xAxisAfterBuildTicks = (axis) => {
                 if (!priceData || priceData.length === 0) return;
                 const newTicks = [];
                 const axisMinDay = axis.min;
                 const axisMaxDay = axis.max;
                 const firstDay = priceData[0];
                 const lastDay = priceData[priceData.length - 1];
                 if (!firstDay || !lastDay) return;
                 const dayRange = lastDay.x - firstDay.x;
                 const timeRange = lastDay.time - firstDay.time;
                 const dayRatio = (dayRange > 0) ? (axisMaxDay - firstDay.x) / dayRange : 0;
                 const estimatedMaxTime = firstDay.time + (dayRatio * timeRange);
                 const minYear = new Date(firstDay.time).getFullYear();
                 const maxYear = !isNaN(estimatedMaxTime) ? new Date(estimatedMaxTime).getFullYear() : minYear;
                 let lastYearFound = minYear - 1;
                 for (const p of priceData) {
                      const year = new Date(p.time).getFullYear();
                      if (year > lastYearFound) {
                           if (p.x >= axisMinDay && p.x <= axisMaxDay) {
                                newTicks.push({ value: p.x, label: year.toString() });
                           }
                           lastYearFound = year;
                      }
                 }
                 const lastDataYear = lastDay ? new Date(lastDay.time).getFullYear() : minYear;
                 if (dayRange > 0 && timeRange > 0 && !isNaN(estimatedMaxTime)) {
                      for (let year = lastDataYear + 1; year <= maxYear; year++) {
                           const yearStartTime = new Date(year, 0, 1).getTime();
                           const timeRatio = (yearStartTime - firstDay.time) / timeRange;
                           const estimatedDayNumber = firstDay.x + (timeRatio * dayRange);
                           if (estimatedDayNumber >= axisMinDay && estimatedDayNumber <= axisMaxDay) {
                                newTicks.push({ value: estimatedDayNumber, label: year.toString() });
                           }
                      }
                 }
                 axis.ticks.length = 0;
                 const validTicks = newTicks.filter(tick => !isNaN(tick.value) && tick.label);
                 axis.ticks.push(...validTicks);
             };

            // --- Chart Update or Creation ---
            const datasetDefaults = {
                type: 'line',
                borderWidth: 1,
                pointRadius: 0,
                fill: false,
                pointStyle: 'line'
            };

            const fillDatasetDefaults = {
                type: 'line',
                pointRadius: 0,
                borderWidth: 0, // No border for fill areas
                pointStyle: 'line', // Keep legend consistent
                hidden: true, // Initially hidden
            }

            if (chart) {
                // Update existing datasets
                chart.data.datasets[0].data = chartPriceData; // Price
                chart.data.datasets[1].data = medianLineData; // 50th Pctl (style updated in applyBandVisibility)
                chart.data.datasets[2].data = p1LineData;     // P1 Line
                chart.data.datasets[3].data = p99LineData;    // P99 Line

                // Update or add new datasets (indices 4+)
                const datasetsToUpdate = [
                    { index: 4, label: '20th Pctl', data: p20LineData, style: grayLineStyle, hidden: true },
                    // Index 5 is now redundant/always hidden
                    { index: 5, label: '50th Pctl (Hidden)', data: medianLineData, style: grayLineStyle, hidden: true },
                    { index: 6, label: '80th Pctl', data: p80LineData, style: grayLineStyle, hidden: true },
                    // Fills - Target needs to be the index of the line below it
                    { index: 7, label: 'Discount Band (P1-P20)', data: p20LineData, fill: 2, backgroundColor: blueFillColor, hidden: true }, // Fill to P1 (idx 2)
                    { index: 8, label: 'Value Band (P20-P50)', data: medianLineData, fill: 4, backgroundColor: greenFillColor, hidden: true }, // Fill to P20 (idx 4)
                    { index: 9, label: 'Expensive Band (P50-P80)', data: p80LineData, fill: 1, backgroundColor: yellowFillColor, hidden: true }, // Fill to Median (idx 1)
                    { index: 10, label: 'Bubble Band (P80-P99)', data: p99LineData, fill: 6, backgroundColor: redFillColor, hidden: true }, // Fill to P80 (idx 6)
                ];

                datasetsToUpdate.forEach(dsInfo => {
                    if (chart.data.datasets[dsInfo.index]) {
                        // Update existing dataset
                        chart.data.datasets[dsInfo.index].data = dsInfo.data;
                        chart.data.datasets[dsInfo.index].label = dsInfo.label;
                         if (dsInfo.style) {
                             Object.assign(chart.data.datasets[dsInfo.index], dsInfo.style);
                         }
                         if (dsInfo.fill !== undefined) {
                              chart.data.datasets[dsInfo.index].fill = dsInfo.fill;
                              chart.data.datasets[dsInfo.index].backgroundColor = dsInfo.backgroundColor;
                         }
                         // Ensure redundant line stays hidden
                         if (dsInfo.index === 5) {
                             chart.data.datasets[dsInfo.index].hidden = true;
                         }
                    } else {
                        // Add new dataset
                         chart.data.datasets.push({
                             ...datasetDefaults,
                             ...(dsInfo.style || {}),
                             ...(dsInfo.fill !== undefined ? fillDatasetDefaults : {}),
                             label: dsInfo.label,
                             data: dsInfo.data,
                             // Ensure redundant line starts hidden
                             hidden: dsInfo.index === 5 ? true : dsInfo.hidden,
                             ...(dsInfo.fill !== undefined && { fill: dsInfo.fill, backgroundColor: dsInfo.backgroundColor }),
                         });
                    }
                });

                 // Apply checkbox state correctly updates styles/visibility
                 applyBandVisibility(showBandsCheckbox.checked);


                // Update scales and redraw
                chart.options.scales.x.min = extendedMinDay;
                chart.options.scales.x.max = extendedMaxDay;
                chart.options.scales.y.min = extendedMinPrice;
                chart.options.scales.y.max = extendedMaxPrice;
                chart.options.scales.x.afterBuildTicks = xAxisAfterBuildTicks; // Re-apply tick builder
                chart.update();

            } else {
                // Create new chart
                chart = new Chart(ctx, {
                    data: {
                        datasets: [
                            { // 0: Price
                                ...datasetDefaults,
                                type: 'line', // Explicitly line
                                label: 'TAO Price',
                                data: chartPriceData,
                                backgroundColor: 'rgba(24, 72, 204, 0.05)',
                                borderColor: 'rgba(24, 72, 204, 1)',
                                borderWidth: 2,
                                pointHoverRadius: 5,
                                tension: 0.1,
                            },
                            { // 1: 50th Percentile (Style changes dynamically)
                                ...datasetDefaults,
                                label: '50th Percentile',
                                data: medianLineData,
                                ...orangeLineStyle, // Start with orange style
                                hidden: false,
                            },
                            { // 2: P1 Line
                                ...datasetDefaults,
                                ...grayLineStyle,
                                label: '1st Pctl',
                                data: p1LineData,
                            },
                            { // 3: P99 Line
                                ...datasetDefaults,
                                ...grayLineStyle,
                                label: '99th Pctl',
                                data: p99LineData,
                            },
                            // --- NEW Datasets (Initially Hidden) ---
                            { // 4: P20 Line (Gray)
                                ...datasetDefaults,
                                ...grayLineStyle,
                                label: '20th Pctl',
                                data: p20LineData,
                                hidden: true,
                            },
                            { // 5: Redundant P50 Line (Gray) - Always hidden
                                ...datasetDefaults,
                                ...grayLineStyle,
                                label: '50th Pctl (Hidden)', // Label for debugging
                                data: medianLineData, // Use same data
                                hidden: true,
                            },
                            { // 6: P80 Line (Gray)
                                ...datasetDefaults,
                                ...grayLineStyle,
                                label: '80th Pctl',
                                data: p80LineData,
                                hidden: true,
                            },
                             // --- NEW Fill Datasets (Initially Hidden) ---
                             { // 7: Fill P1-P20 (Blue)
                                 ...fillDatasetDefaults,
                                 label: 'Discount Band (P1-P20)',
                                 data: p20LineData, // Use upper boundary data
                                 fill: 2, // Fill down to index 2 (P1 Line)
                                 backgroundColor: blueFillColor,
                             },
                             { // 8: Fill P20-P50 (Green)
                                 ...fillDatasetDefaults,
                                 label: 'Value Band (P20-P50)',
                                 data: medianLineData, // Use upper boundary data (index 1)
                                 fill: 4, // Fill down to index 4 (P20 Line)
                                 backgroundColor: greenFillColor,
                             },
                            { // 9: Fill P50-P80 (Yellow)
                                 ...fillDatasetDefaults,
                                 label: 'Expensive Band (P50-P80)',
                                 data: p80LineData, // Use upper boundary data
                                 fill: 1, // Fill down to index 1 (Main P50 Line)
                                 backgroundColor: yellowFillColor,
                             },
                            { // 10: Fill P80-P99 (Red)
                                 ...fillDatasetDefaults,
                                 label: 'Bubble Band (P80-P99)',
                                 data: p99LineData, // Use upper boundary data
                                 fill: 6, // Fill down to index 6 (P80 Line)
                                 backgroundColor: redFillColor,
                             },
                        ]
                    },
                    options: { // Standard chart options remain largely the same
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#374151', usePointStyle: true, boxWidth: 30, boxHeight: 12,
                                    // Filter out fill datasets and hidden lines
                                    filter: function(item, chart) {
                                         // Hide fills and the redundant 50th line (index 5)
                                         return !item.text.includes('Band') && item.datasetIndex !== 5;
                                     }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                     title: function(tooltipItems) {
                                         if (tooltipItems.length > 0) {
                                             const item = tooltipItems[0];
                                             const dayNumber = item.parsed.x;
                                             if (item.datasetIndex === 0) {
                                                 const dataPoint = priceData.find(p => p.x === dayNumber);
                                                 if (dataPoint) {
                                                     const date = new Date(dataPoint.time);
                                                     return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
                                                 }
                                             }
                                             const displayDay = !isNaN(dayNumber) ? (dayNumber - DAY_OFFSET).toFixed(0) : 'N/A';
                                             return `Day ~${displayDay}`;
                                         }
                                         return '';
                                     },
                                     label: (context) => {
                                         // Hide tooltip label for fills and redundant 50th line
                                         if (context.dataset.label.includes('Band') || context.datasetIndex === 5) return null;
                                         return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                                     }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic', min: extendedMinDay, max: extendedMaxDay,
                                title: { display: true, text: `Time (Log Scale)`, color: '#4b5563' },
                                ticks: { color: '#4b5563', autoSkip: false,
                                     callback: function(value, index, ticks) {
                                         const tick = this.getTicks().find(t => t.value === value);
                                         return tick ? tick.label : null;
                                     }
                                },
                                afterBuildTicks: xAxisAfterBuildTicks,
                                grid: { color: 'rgba(0, 0, 0, 0.1)' }
                            },
                            y: {
                                type: 'logarithmic', min: extendedMinPrice, max: extendedMaxPrice,
                                title: { display: true, text: 'Price (Log Scale)', color: '#4b5563' },
                                ticks: { color: '#4b5563',
                                     callback: function(value, index, ticks) {
                                         const tick = this.getTicks().find(t => t.value === value);
                                         return tick ? tick.label : null;
                                     }
                                },
                                afterBuildTicks: (axis) => { // Y-axis tick builder
                                     if (!axis.chart.data || !axis.chart.data.datasets || axis.chart.data.datasets.length === 0) return;
                                     const newTicks = [];
                                     const axisMin = axis.min;
                                     const axisMax = axis.max;
                                     if (axisMin <= 0 || axisMax <= 0 || axisMin >= axisMax) {
                                          axis.ticks = [{value: 1, label: '$1'}]; return;
                                     }
                                     let tickValue = Math.pow(10, Math.floor(Math.log10(axisMin)));
                                     while (tickValue <= axisMax * 1.1) {
                                         if (tickValue >= axisMin * 0.9) {
                                             newTicks.push({ value: tickValue, label: `$${tickValue.toLocaleString()}` });
                                         }
                                         let nextTick = tickValue * 10;
                                         if (nextTick <= tickValue || !isFinite(nextTick)) { break; }
                                         tickValue = nextTick;
                                     }
                                     axis.ticks.length = 0;
                                     const validTicks = newTicks.filter(tick => isFinite(tick.value) && tick.value > 0);
                                     axis.ticks.push(...validTicks);
                                      if (axis.ticks.length === 0) {
                                          axis.ticks.push({ value: axisMin, label: `$${axisMin.toLocaleString()}` });
                                          axis.ticks.push({ value: axisMax, label: `$${axisMax.toLocaleString()}` });
                                      }
                                 },
                                grid: { color: 'rgba(0, 0, 0, 0.1)' }
                            }
                        }
                    }
                });
            }

             // --- NEW: Show checkbox and add listener after chart setup ---
              showBandsContainer.classList.remove('hidden');
              // Remove previous listener to avoid duplicates if function runs again
              showBandsCheckbox.removeEventListener('change', handleBandToggle);
              showBandsCheckbox.addEventListener('change', handleBandToggle);
               // Apply initial state based on checkbox
               applyBandVisibility(showBandsCheckbox.checked);
               if(chart) chart.update('none'); // Update once without animation after applying initial visibility
              // --- END ---
        }

        // --- NEW: Function to handle checkbox toggling ---
        function handleBandToggle() {
             if (!chart) return;
             const showBands = showBandsCheckbox.checked;
             applyBandVisibility(showBands);
             chart.update(); // Update chart after visibility changes
        }

        // --- MODIFIED: applyBandVisibility to change style of dataset 1 ---
        function applyBandVisibility(showBands) {
             if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length < 11) {
                console.error("Chart or datasets not fully initialized for applyBandVisibility.");
                return; // Exit if chart/datasets aren't ready
             }
             // Indices
             const mainMedianIndex = 1;    // The one that changes color
             const p20Index = 4;
             const redundantP50Index = 5; // Always hidden
             const p80Index = 6;
             const fillIndices = [7, 8, 9, 10]; // P1-P20, P20-P50, P50-P80, P80-P99

             // Always visible lines (ensure they exist first)
              if (chart.data.datasets[0]) chart.setDatasetVisibility(0, true); // Price
              if (chart.data.datasets[mainMedianIndex]) chart.setDatasetVisibility(mainMedianIndex, true); // Main 50th is always visible now
              if (chart.data.datasets[2]) chart.setDatasetVisibility(2, true); // P1
              if (chart.data.datasets[3]) chart.setDatasetVisibility(3, true); // P99
              if (chart.data.datasets[redundantP50Index]) chart.setDatasetVisibility(redundantP50Index, false); // Keep redundant one hidden


             // Toggle visibility of band lines and fills
              if (chart.data.datasets[p20Index]) chart.setDatasetVisibility(p20Index, showBands);
              if (chart.data.datasets[p80Index]) chart.setDatasetVisibility(p80Index, showBands);
              fillIndices.forEach(index => {
                   if (chart.data.datasets[index]) chart.setDatasetVisibility(index, showBands);
              });


             // Change style of main 50th percentile line
             const medianDataset = chart.data.datasets[mainMedianIndex];
              if (medianDataset) { // Check if dataset exists
                  if (showBands) {
                      // Apply gray style
                      medianDataset.borderColor = grayLineStyle.borderColor;
                      medianDataset.borderWidth = grayLineStyle.borderWidth;
                  } else {
                      // Apply orange style
                      medianDataset.borderColor = orangeLineStyle.borderColor;
                      medianDataset.borderWidth = orangeLineStyle.borderWidth;
                  }
              } else {
                  console.error("Median dataset (index 1) not found for style change.");
              }
        }
         // --- END MODIFICATION ---

        function calculateRSquared(data, slope, intercept) {
            let ss_tot = 0, ss_res = 0, y_mean = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length < 2) return 0;
            validData.forEach(p => y_mean += Math.log10(p.y));
            y_mean /= validData.length;
            validData.forEach(p => {
                const logY = Math.log10(p.y);
                const logX = Math.log10(p.x);
                const predictedLogY = slope * logX + intercept;
                ss_tot += Math.pow(logY - y_mean, 2);
                ss_res += Math.pow(logY - predictedLogY, 2);
            });
             return ss_tot === 0 ? 1 : Math.max(0, 1 - (ss_res / ss_tot));
        }


        // --- FULLSCREEN & MOBILE VIEW LOGIC ---

        const mainContainer = document.getElementById('mainContainer');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fsIconEnter = document.getElementById('fsIconEnter');
        const fsIconExit = document.getElementById('fsIconExit');
        const headerElement = document.querySelector('header');
        const bottomBarElement = document.getElementById('bottomModelBar');
        const topBarElement = document.getElementById('topStatusBar');
        const chartCardElement = document.getElementById('chartCard');


        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (mainContainer.requestFullscreen) {
                    mainContainer.requestFullscreen().catch(err => console.error(`Error entering fullscreen: ${err.message}`));
                } else if (mainContainer.webkitRequestFullscreen) {
                    mainContainer.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().catch(err => console.error(`Error exiting fullscreen: ${err.message}`));
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
             requestAnimationFrame(() => {
                 const isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                 const isMobile = window.innerWidth < 640;
                 const isLandscape = screen.orientation ? screen.orientation.type.includes('landscape') : window.innerWidth > window.innerHeight;

                 if (isInFullscreen) {
                     fsIconEnter.classList.add('hidden');
                     fsIconExit.classList.remove('hidden');
                     fullscreenBtn.setAttribute('title', 'Exit Fullscreen');
                 } else {
                     fsIconEnter.classList.remove('hidden');
                     fsIconExit.classList.add('hidden');
                     fullscreenBtn.setAttribute('title', 'Enter Fullscreen');
                 }

                 // Reset styles first
                 if (headerElement) headerElement.style.display = '';
                 if (bottomBarElement) bottomBarElement.style.display = '';
                 if (topBarElement) topBarElement.style.display = '';
                 if (chartCardElement) chartCardElement.style.padding = '';

                 // Apply mobile landscape styles
                 if (isInFullscreen && isMobile && isLandscape) {
                     if (headerElement) headerElement.style.display = 'none';
                     if (bottomBarElement) bottomBarElement.style.display = 'none';
                     if (chartCardElement) chartCardElement.style.padding = '0';
                 }

                  if (chart) {
                       setTimeout(() => {
                           requestAnimationFrame(() => {
                                if (chart) chart.resize();
                           });
                       }, 50);
                   }
             });
         }


        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        window.addEventListener('resize', handleFullscreenChange);
         if (screen.orientation) {
              screen.orientation.addEventListener('change', handleFullscreenChange);
         } else {
              window.addEventListener('orientationchange', handleFullscreenChange);
         }


        window.onload = () => {
            createOrUpdateChart();
            setTimeout(handleFullscreenChange, 150);
        }

        // --- END OF FULLSCREEN & MOBILE LOGIC ---
    </script>

</body>
</html>


