<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAO Tensor Law Model</title>
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Internal Styles -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Loader animation */
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ff6d00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Colored status dot */
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        /* --- Fullscreen CSS Logic --- */
        
        /* Override body flex-centering when in fullscreen */
        body:has(#mainContainer:fullscreen) {
            display: block;
        }

        /* Main container expands to fill viewport in fullscreen */
        #mainContainer:fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none !important;
            border-radius: 0 !important;
            display: flex;
            flex-direction: column;
        }

        /* Chart card grows to fill available space */
        #mainContainer:fullscreen #chartCard {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* Chart wrapper (which contains canvas) grows */
        #mainContainer:fullscreen #chartWrapper {
            height: 100% !important;
            flex-grow: 1;
        }

        /* Hide footer when in fullscreen */
        body:has(#mainContainer:fullscreen) footer {
            display: none;
        }

        /* --- Mobile Fullscreen Optimizations --- */

        /* Show "Please Rotate" overlay in portrait fullscreen */
        @media (max-width: 639px) and (orientation: portrait) {
            #mainContainer:fullscreen #rotateOverlay {
                display: flex !important;
            }
            /* Hide all other UI elements */
            #mainContainer:fullscreen header,
            #mainContainer:fullscreen #topStatusBar,
            #mainContainer:fullscreen #chartCard,
            #mainContainer:fullscreen #bottomModelBar,
            #mainContainer:fullscreen #fullscreenBtn {
                display: none !important;
            }
        }

        /* Styles applied by JS for mobile LANDSCAPE fullscreen */
        #mainContainer.mobile-fullscreen-landscape header,
        #mainContainer.mobile-fullscreen-landscape #bottomModelBar {
             display: none !important;
        }
         #mainContainer.mobile-fullscreen-landscape #chartCard {
             padding: 0 !important;
         }
         #mainContainer.mobile-fullscreen-landscape #topStatusBar {
             display: flex !important;
         }
        /* --- END: Mobile Fullscreen Optimizations --- */

        /* --- Projection Table Styles --- */
        #projectionTable {
            position: absolute;
            top: 12%;
            left: 10%;
            z-index: 5; /* Below loader (10) but above chart */
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.5rem 0.75rem; /* p-2 p-3 */
            font-size: 0.75rem; /* text-xs */
            line-height: 1.15rem;
            color: #374151; /* text-gray-700 */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* shadow-md */
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        #projectionTable h3 {
            font-weight: 600; /* font-semibold */
            color: #1f2937; /* text-gray-800 */
            margin-bottom: 0.25rem; /* mb-1 */
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #projectionTable div {
            display: flex;
            justify-content: space-between;
        }
        #projectionTable div span:first-child {
            margin-right: 1.25rem; /* mr-5 */
            color: #4b5563; /* text-gray-600 */
        }
        #projectionTable div span:last-child {
            font-weight: 500; /* font-medium */
            color: #1f2937; /* text-gray-800 */
        }
        #projectionTable h3 button {
            margin-left: 0.5rem; /* ml-2 */
            color: #9ca3af; /* text-gray-400 */
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }
         #projectionTable h3 button:hover {
           color: #374151; /* hover:text-gray-700 */
         }
        /* --- END: Projection Table Styles --- */
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center h-screen p-2">

    <!-- 
      Main application container.
     -->
    <div id="mainContainer" class="w-full flex-grow max-w-[1920px] max-h-[1080px] min-h-[30rem] flex flex-col bg-white rounded-lg shadow-xl p-2 sm:p-3 md:p-4 relative">

        <!-- Overlay to show on mobile fullscreen portrait -->
        <div id="rotateOverlay" class="hidden absolute inset-0 w-full h-full bg-white/95 z-50 flex-col items-center justify-center text-center p-8">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 text-gray-600 mb-4 animate-pulse">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.992 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
            <h2 class="text-2xl font-semibold text-gray-800 mb-2">Please Rotate Your Device</h2>
            <p class="text-gray-600">This chart is best viewed in landscape mode.</p>
        </div>

        <!-- Fullscreen toggle button -->
        <button id="fullscreenBtn" onclick="toggleFullScreen()" class="absolute top-4 right-4 sm:top-6 sm:right-6 text-gray-400 hover:text-gray-800 transition-colors z-20 p-1 rounded-full hover:bg-gray-100" title="Toggle Fullscreen">
            <svg id="fsIconEnter" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m4.5 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
            </svg>
            <svg id="fsIconExit" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 hidden">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 9L3.75 3.75M9 9h4.5m-4.5 0v4.5m0-4.5L3.75 3.75M9 15l-5.25 5.25M9 15h4.5m-4.5 0v-4.5m0 4.5l-5.25 5.25M15 9l5.25-5.25M15 9h-4.5m4.5 0v4.5m0-4.5l5.25-5.25M15 15l5.25 5.25M15 15h-4.5m4.5 0v-4.5m0 4.5l5.25 5.25" />
            </svg>
        </button>
        
        <!-- Page Header -->
        <header class="text-center mb-3">
            <h1 class="text-xl sm:text-2xl md:text-3xl text-gray-900">TAO Tensor Law Model</h1>
        </header>

        <!-- Top Status Bar: Data status, price, bands toggle -->
        <div id="topStatusBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mb-2 text-sm text-gray-600 px-4">
             <div id="statusDiv" class="flex items-center">
                 <span class="status-dot bg-yellow-400"></span>Loading latest data...
             </div>
             <div id="lastUpdateDiv" class="hidden sm:block"></div>
             <div id="lastPriceDiv" class="hidden sm:block"></div>
             <div id="priceZoneDiv" class="flex items-center hidden sm:block"></div>
             
             <!-- Bands Toggle Checkbox -->
             <div id="showBandsContainer" class="flex items-center hidden">
                 <input type="checkbox" id="showBandsCheckbox" class="mr-1.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                 <label for="showBandsCheckbox" class="cursor-pointer mr-1">Bands&nbsp;</label>
                 <span title="Blue: Discount (P1-P20), Green: Value (P20-P50), Yellow: Expensive (P50-P80), Red: Bubble (P80-P99)" class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
             </div>
        </div>

        <!-- Chart Card: Contains loader and canvas wrapper -->
        <div id="chartCard" class="bg-white p-2 rounded-lg relative flex-grow flex flex-col min-h-0">
            <!-- Loading Spinner -->
            <div id="loader" class="absolute inset-0 bg-white/80 flex items-center justify-center z-10">
                <div class="loader"></div>
            </div>
            <!-- Canvas Wrapper: Scales to fill parent card -->
            <div id="chartWrapper" class="relative flex-grow min-h-0">
                <div id="projectionTable" class="hidden"></div>
                <canvas id="powerLawChart"></canvas>
            </div>

            <!-- Bottom Model Info Bar: Model parameters -->
            <div id="bottomModelBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mt-2 text-sm text-gray-600">
                <div id="growthExponentDiv"></div>                   
                <div id="modelParamDiv"></div> <!-- Renamed from optimalOffsetDiv -->
                <!-- NEW: Replaced dropdown with checkbox -->
                <div class="flex items-center">
                    <input type="checkbox" id="useOptimalOffsetCheckbox" class="mr-1.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" checked>
                    <label for="useOptimalOffsetCheckbox" class="cursor-pointer mr-1">Use Optimal&nbsp;</label>
                    <span title="Overrides the hard-coded model offset and uses the dynamically calculated optimal fit." class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
                </div>
                <div id="modelFitDiv"></div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center p-1 mt-2">
        <p class="text-gray-600 text-xs">&copy; 2025 <a href="https://decodejar.com" target="_blank" rel="noopener noreferrer" class="hover:text-indigo-500 transition-colors">DECODEJAR.COM</a>. All Rights Reserved. Disclaimer: This tool is for informational and research purposes only and does not constitute financial or trading advice. Past performance is not indicative of future results.</p>
    </footer>

<script>
        /*
         * TAO Tensor Law Model & Regression Logic
         * Copyright (c) 2025 Decodejar.com. All Rights Reserved.
         */

        // --- Global Element References ---
        const growthExponentDiv = document.getElementById('growthExponentDiv');
        const modelFitDiv = document.getElementById('modelFitDiv');
        const loader = document.getElementById('loader');
        const statusDiv = document.getElementById('statusDiv');
        const lastUpdateDiv = document.getElementById('lastUpdateDiv');
        const lastPriceDiv = document.getElementById('lastPriceDiv');
        const priceZoneDiv = document.getElementById('priceZoneDiv');
        const ctx = document.getElementById('powerLawChart').getContext('2d');
        const modelParamDiv = document.getElementById('modelParamDiv'); // Renamed
        const showBandsContainer = document.getElementById('showBandsContainer');
        const showBandsCheckbox = document.getElementById('showBandsCheckbox');
        const projectionTable = document.getElementById('projectionTable');
        const useOptimalOffsetCheckbox = document.getElementById('useOptimalOffsetCheckbox'); // NEW

        // --- Chart Configuration ---
        const HARDCODED_OFFSET = 74; // Renamed from DAY_OFFSET
        const MAX_OFFSET_SEARCH_LIMIT = 730; // NEW: Max offset value to test
        // --- NEW: Configurable Padding Constants ---
        const X_AXIS_PROJECTION_PADDING = 0.33; // 33% log-time projection
        const Y_AXIS_BOTTOM_PADDING = 0.1; // 10% log-space padding
        const Y_AXIS_TOP_PADDING_MIN = 0.1; // Min 10% log-space padding (zoomed in)
        const Y_AXIS_TOP_PADDING_MAX = 0.33; // Max 33% log-space padding (zoomed out)
        // --- END NEW ---
        let chart; // Global chart instance
        let baseData = []; // NEW: Made global for tooltip scope
        let priceData = []; // NEW: Made global for zoom and tooltips
        let activeModelParams = {}; // NEW: Stores params of the active model
        // NEW: Zoom state
        let originalExtendedMinDay = 1;
        let originalExtendedMaxDay = 1000;
        const ZOOM_FACTOR = 0.1; // NEW: Zoom 10% per scroll
        // NEW: Panning state
        let isPanning = false;
        let panStartX = 0;
        let panStartMin = 0;
        let panStartLogRange = 0; // NEW
 
        // Band Fill Colors
        const blueFillColor = 'rgba(147, 197, 253, 0.1)';
        const greenFillColor = 'rgba(34, 197, 94, 0.1)';
        const yellowFillColor = 'rgba(250, 204, 21, 0.1)';
        const redFillColor = 'rgba(239, 68, 68, 0.1)';

        // Reusable Line Styles
        const grayLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 1 };
        const orangeLineStyle = { borderColor: '#ff6d00', borderWidth: 2 };
        const grayDashedLineStyle = { borderColor: 'rgba(156, 163, 175, 0.9)', borderWidth: 1, borderDash: [2, 2] };
        const grayFineLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 0.5, borderDash: [] };

        /**
         * Fetches and parses price data from JSON file.
         */
        async function loadPriceData() {
            try {
                const response = await fetch(`./price_data.json?t=${new Date().getTime()}`); // Cache-bust
                if (!response.ok) throw new Error(`Failed to load data file: ${response.statusText}`);
                const data = await response.json();
                 if (!Array.isArray(data)) throw new Error("Invalid data format in JSON file");
                // Store in global baseData
                baseData = data.map((p, i) => ({ time: p[0] * 1000, dayIndex: i + 1, y: p[1] })).filter(p => p.y > 0);
                return baseData;
            } catch (error) {
                console.error("Error loading price data:", error);
                statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>Error loading data. Check console.`;
                loader.style.display = 'none';
                return null;
            }
        }

        /**
         * Performs linear regression on log-transformed data.
         */
        function linearRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            const n = validData.length;
            if (n < 2) return { slope: 0, intercept: 0 }; 
            
            for (const { x, y } of validData) {
                const logX = Math.log10(x);
                const logY = Math.log10(y);
                sumX += logX; sumY += logY; sumXY += logX * logY; sumX2 += logX * logX;
            }

            const denominator = (n * sumX2 - sumX * sumX);
            if (denominator === 0) return { slope: 0, intercept: 0 }; 
            
            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept };
        }

        /**
         * Calculates sorted residuals (logY - predictedLogY) from the mean regression line.
         */
        function calculateResiduals(data, slope, intercept) {
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length === 0) return [];
            return validData.map(p => {
                const logX = Math.log10(p.x);
                const logY = Math.log10(p.y);
                const predictedLogY = slope * logX + intercept;
                return logY - predictedLogY;
            }).sort((a, b) => a - b); 
        }

        /**
         * Gets a specific percentile value from a pre-sorted array of residuals.
         */
        function getPercentile(sortedResiduals, percentile) {
            if (!sortedResiduals || sortedResiduals.length === 0) return 0;
            const index = (percentile / 100) * (sortedResiduals.length - 1);
            const lowerIndex = Math.floor(index);
            const upperIndex = Math.ceil(index);
            
            if (lowerIndex === upperIndex) {
                 return sortedResiduals[lowerIndex];
            } else {
                 const weight = index - lowerIndex;
                 return sortedResiduals[lowerIndex] * (1 - weight) + sortedResiduals[upperIndex] * weight;
            }
        }

        /**
         * Finds the optimal day offset by testing a range of values.
         */
        function findOptimalOffset(baseData, minOffset = 1, maxOffset) {
            let bestOffset = -1;
            let bestRSquared = -Infinity;

            if (baseData.length < 2) return { optimalOffset: -1, bestFit: 0 };
            if (typeof maxOffset === 'undefined' || maxOffset < minOffset) maxOffset = baseData.length; 

            for (let offset = minOffset; offset <= maxOffset; offset++) {
                const offsetData = baseData.map(p => ({ x: p.dayIndex + offset, y: p.y }));
                const { slope, intercept } = linearRegression(offsetData);
                if (slope === 0 && intercept === 0 && offsetData.length > 1) continue; 
                
                const rSquared = calculateRSquared(offsetData, slope, intercept);
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestOffset = offset;
                }
            }
            return { optimalOffset: bestOffset, bestFit: bestRSquared };
        }

        /**
         * Main function to load data, run calculations, and create or update the chart.
         */
        async function createOrUpdateChart() {
            loader.style.display = 'flex';
            // Use global baseData
            if (baseData.length === 0) {
                await loadPriceData();
            }

            if (!baseData || baseData.length === 0) {
                 if (!statusDiv.innerHTML.includes('Error')) {
                     statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>No valid data to display.`;
                 }
                 growthExponentDiv.innerHTML = '<strong>Exponent (α):</strong> N/A';
                 modelParamDiv.innerHTML = '<strong>Day Offset:</strong> N/A';
                 modelFitDiv.innerHTML = '<strong>Fit (R²):</strong> N/A';
                 if (useOptimalOffsetCheckbox) useOptimalOffsetCheckbox.disabled = true;
                 showBandsContainer.classList.add('hidden');
                 loader.style.display = 'none';
                 return;
            }

            // --- 1. GET MODEL PARAMETERS BASED ON SELECTION ---
            const useOptimal = useOptimalOffsetCheckbox.checked;
            let slope, meanIntercept, rSquared;
            let activeDayOffset;
            
            // Find optimal offset, but only search up to our defined limit
            const { optimalOffset, bestFit: optimalOffsetRSquared } = findOptimalOffset(baseData, 1, MAX_OFFSET_SEARCH_LIMIT);
            
            if (useOptimal) {
                activeDayOffset = optimalOffset;
                priceData = baseData.map(p => ({ ...p, x: p.dayIndex + optimalOffset }));
                const regression = linearRegression(priceData);
                slope = regression.slope;
                meanIntercept = regression.intercept;
                rSquared = optimalOffsetRSquared; // We already have this
                modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${optimalOffset}`;
            } else {
                activeDayOffset = HARDCODED_OFFSET;
                priceData = baseData.map(p => ({ ...p, x: p.dayIndex + HARDCODED_OFFSET }));
                const regression = linearRegression(priceData);
                slope = regression.slope;
                meanIntercept = regression.intercept;
                rSquared = calculateRSquared(priceData, slope, meanIntercept);
                // Show comparison to optimal
                if (optimalOffset !== -1 && optimalOffset !== HARDCODED_OFFSET) {
                     modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${HARDCODED_OFFSET} | <strong>Optimal:</strong> ${optimalOffset} (R² ${optimalOffsetRSquared.toFixed(4)})`;
                } else {
                     modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${HARDCODED_OFFSET}`;
                }
            }
            
            // Store final model params
            activeModelParams = {
                modelType: useOptimal ? 'optimalOffset' : 'hardcoded',
                activeDayOffset: activeDayOffset,
                slope: slope,
                meanIntercept: meanIntercept
            };

            // --- 2. UPDATE UI & CALCULATE AXES (using model data) ---
            if (useOptimalOffsetCheckbox) useOptimalOffsetCheckbox.disabled = false;
            
            // NEW: Use the *last point of the full baseData* for UI
            const lastBaseDataPoint = baseData[baseData.length - 1];
            const lastTimestamp = lastBaseDataPoint.time; 
            const lastUpdateDate = new Date(lastTimestamp).toLocaleDateString(undefined, {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            statusDiv.innerHTML = `<span class="status-dot bg-green-500"></span>Data Loaded`;
            lastUpdateDiv.innerHTML = `<strong>Updated:</strong> ${lastUpdateDate}`;
            lastPriceDiv.innerHTML = `<strong>Price:</strong> $${lastBaseDataPoint.y.toFixed(2)}`;
            lastUpdateDiv.classList.remove('hidden');
            lastPriceDiv.classList.remove('hidden');

            // NEW: Calculate axis ranges based on the *full priceData*
            const chartPrices = priceData.map(p => p.y);
            const minPrice = Math.min(...chartPrices);
            const maxPrice = Math.max(...chartPrices);

            // X-Axis Range (with projection)
            const n = priceData.length; // Use full data length
            const firstDayNum = priceData[0].x;
            const lastDayNum = priceData[n - 1].x; // Use last point of full data

            // --- NEW LOGIC: Project X-axis by 40% of log range ---
            const logMinDay = Math.log10(firstDayNum);
            const logMaxDay = Math.log10(lastDayNum);
            const logDayRange = logMaxDay - logMinDay;

            const extendedMinDay = firstDayNum;
            let extendedMaxDay;

            if (logDayRange > 0) {
                const extendedLogMaxDay = logMaxDay + (logDayRange * X_AXIS_PROJECTION_PADDING); // USE CONSTANT
                extendedMaxDay = Math.pow(10, extendedLogMaxDay);
            } else {
                // Fallback for single data point
                extendedMaxDay = lastDayNum * 1.4; 
            }
            // --- END NEW LOGIC ---
 
            // NEW: Store the full range for this model for zoom reset
            originalExtendedMinDay = extendedMinDay;
            originalExtendedMaxDay = extendedMaxDay;
 
            // Y-Axis Range (with padding)
            const logMinPrice = Math.log10(minPrice);
            const logMaxPrice = Math.log10(maxPrice);
            const logPriceRange = logMaxPrice - logMinPrice;
            const extendedMinPrice = logPriceRange > 0 ? Math.pow(10, logMinPrice - logPriceRange * Y_AXIS_BOTTOM_PADDING) : minPrice * 0.9; // USE CONSTANT
            const extendedMaxPrice = logPriceRange > 0 ? Math.pow(10, logMaxPrice + logPriceRange * Y_AXIS_TOP_PADDING_MAX) : maxPrice * 1.4; // USE MAX CONSTANT

            // --- 3. MODEL CALCULATIONS (using *active* priceData) ---
            // NEW: Get last point from *regression* data for price zone
            const lastModelDataPoint = priceData[priceData.length - 1];
            const sortedResiduals = calculateResiduals(priceData, slope, meanIntercept);

            const medianResidual = getPercentile(sortedResiduals, 50);
            const p1Residual = getPercentile(sortedResiduals, 1);
            const p99Residual = getPercentile(sortedResiduals, 99);
            const p20Residual = getPercentile(sortedResiduals, 20);
            const p80Residual = getPercentile(sortedResiduals, 80);

            // Determine current price zone
            const lastLogX = Math.log10(lastModelDataPoint.x);
            const lastLogY = Math.log10(lastModelDataPoint.y);
            const predictedLastLogY = slope * lastLogX + meanIntercept;
            const lastResidual = lastLogY - predictedLastLogY;

            let priceZone = "";
            let priceZoneColor = "";
            if (lastResidual > p80Residual) { priceZone = "Bubble"; priceZoneColor = "bg-red-500"; }
            else if (lastResidual > medianResidual) { priceZone = "Expensive"; priceZoneColor = "bg-yellow-400"; }
            else if (lastResidual > p20Residual) { priceZone = "Value"; priceZoneColor = "bg-green-500"; }
            else { priceZone = "Discount"; priceZoneColor = "bg-blue-300"; }

            priceZoneDiv.innerHTML = `<span class="status-dot ${priceZoneColor}"></span><strong>Rating:</strong>&nbsp;${priceZone}`;
            priceZoneDiv.classList.remove('hidden');

            const medianIntercept = meanIntercept + medianResidual;
            const p1Intercept = meanIntercept + p1Residual;
            const p99Intercept = meanIntercept + p99Residual;
            const p20Intercept = meanIntercept + p20Residual;
            const p80Intercept = meanIntercept + p80Residual;

            // Call projection function (passes full baseData for date calculations)
            calculateProjections(baseData, activeModelParams, projectionTable);

            // --- Update Bottom Status Bar ---
            growthExponentDiv.innerHTML = `<strong>Exponent (α):</strong> ${slope.toFixed(3)}`;
            
            let fitColorClass = "";
            if (rSquared >= 0.9) fitColorClass = "bg-blue-300";
            else if (rSquared >= 0.7) fitColorClass = "bg-green-500";
            else if (rSquared >= 0.5) fitColorClass = "bg-yellow-400";
            else fitColorClass = "bg-red-500";
            
            modelFitDiv.innerHTML = `<span class="status-dot ${fitColorClass}"></span><strong>Fit (R²):</strong> ${rSquared.toFixed(4)}`;
            
            // --- 4. GENERATE CHART DATA ---
            const startIndex = extendedMinDay;
            const endIndex = extendedMaxDay;
            const calculateLinePoints = (intercept) => {
                 const safeStartIndex = Math.max(startIndex, 1); 
                 const safeEndIndex = Math.max(endIndex, 1);
                 return [
                      { x: startIndex, y: Math.pow(10, slope * Math.log10(safeStartIndex) + intercept) },
                      { x: endIndex, y: Math.pow(10, slope * Math.log10(safeEndIndex) + intercept) }
                 ];
            };
            const medianLineData = calculateLinePoints(medianIntercept);
            const p1LineData = calculateLinePoints(p1Intercept);
            const p99LineData = calculateLinePoints(p99Intercept);
            const p20LineData = calculateLinePoints(p20Intercept);
            const p80LineData = calculateLinePoints(p80Intercept);

            const chartPriceDataPoints = priceData.map(p => ({ x: p.x, y: p.y }));

            loader.style.display = 'none';

            // --- X-Axis Tick Generation ---
             const xAxisAfterBuildTicks = (axis) => {
                 if (!priceData || priceData.length === 0 || !baseData || baseData.length === 0) return;
                 
                 const newTicks = [];
                 const axisMinDay = axis.min;
                 const axisMaxDay = axis.max;

                 const { activeDayOffset } = activeModelParams;

                 // --- NEW LOGIC to find maxYear ---
                 const firstDayIndex = baseData[0].dayIndex;
                 const firstDayTime = baseData[0].time;
                 const lastDayIndex = baseData[baseData.length - 1].dayIndex;
                 const lastDayTime = baseData[baseData.length - 1].time;
                 
                 let maxYear;

                 if (lastDayIndex > firstDayIndex) {
                     // Estimate ms per dayIndex
                     const msPerDay = (lastDayTime - firstDayTime) / (lastDayIndex - firstDayIndex);
                     // Find the projected dayIndex at the end of the axis
                     const maxDayIndexOnAxis = axisMaxDay - activeDayOffset;
                     // Estimate the time of that projected dayIndex
                     const projectedTime = firstDayTime + (maxDayIndexOnAxis - firstDayIndex) * msPerDay;
                     maxYear = new Date(projectedTime).getFullYear();
                 } else {
                     // Fallback if data is weird (e.g., only one day)
                     maxYear = new Date(lastDayTime).getFullYear() + 5;
                 }
                 // --- END NEW LOGIC ---
                 
                 let lastYearFound = -1; 
                 // Iterate through all years from the start of the *base* data
                 for (let year = new Date(baseData[0].time).getFullYear(); year <= maxYear; year++) {
                    // Find the first data point in baseData for this year
                    const yearStartTime = new Date(year, 0, 1).getTime();
                    const dayData = baseData.find(p => p.time >= yearStartTime);
                    
                    if (!dayData) continue; // Year is too far in future

                    // Convert this dayIndex to the model's x-value
                    const xValue = dayData.dayIndex + activeDayOffset;

                    if (xValue >= axisMinDay && xValue <= axisMaxDay && year !== lastYearFound) {
                         newTicks.push({ value: xValue, label: year.toString() });
                         lastYearFound = year;
                    }
                 }
                 
                 axis.ticks.length = 0; // Clear existing ticks
                 const validTicks = newTicks.filter(tick => !isNaN(tick.value) && tick.label);
                 axis.ticks.push(...validTicks);
             };
 
            // --- 5. CHART UPDATE OR CREATION ---
            const datasetDefaults = {
                type: 'line', borderWidth: 1, pointRadius: 0, fill: false, pointStyle: 'line'
            };
            const fillDatasetDefaults = {
                type: 'line', pointRadius: 0, borderWidth: 0, pointStyle: 'line', hidden: true,
            };

            if (chart) {
                // --- Update Existing Chart ---
                chart.data.datasets[0].data = chartPriceDataPoints;
                chart.data.datasets[1].data = medianLineData;
                chart.data.datasets[2].data = p1LineData;
                chart.data.datasets[3].data = p99LineData;

                const datasetsToUpdate = [
                    { index: 4, label: '20th Pctl', data: p20LineData, style: grayLineStyle, hidden: true },
                    { index: 5, label: '50th Pctl (Hidden)', data: medianLineData, style: grayLineStyle, hidden: true },
                    { index: 6, label: '80th Pctl', data: p80LineData, style: grayLineStyle, hidden: true },
                    { index: 7, label: 'Discount Band (P1-P20)', data: p20LineData, fill: 2, backgroundColor: blueFillColor, hidden: true },
                    { index: 8, label: 'Value Band (P20-P50)', data: medianLineData, fill: 4, backgroundColor: greenFillColor, hidden: true },
                    { index: 9, label: 'Expensive Band (P50-P80)', data: p80LineData, fill: 1, backgroundColor: yellowFillColor, hidden: true },
                    { index: 10, label: 'Bubble Band (P80-P99)', data: p99LineData, fill: 6, backgroundColor: redFillColor, hidden: true },
                ];

                datasetsToUpdate.forEach(dsInfo => {
                    if (chart.data.datasets[dsInfo.index]) {
                        Object.assign(chart.data.datasets[dsInfo.index], {
                            data: dsInfo.data, label: dsInfo.label, ...(dsInfo.style || {}),
                            ...(dsInfo.fill !== undefined && { fill: dsInfo.fill, backgroundColor: dsInfo.backgroundColor }),
                            hidden: dsInfo.index === 5 ? true : dsInfo.hidden,
                        });
                    } else {
                         chart.data.datasets.push({
                             ...datasetDefaults, ...(dsInfo.style || {}),
                             ...(dsInfo.fill !== undefined ? fillDatasetDefaults : {}),
                             label: dsInfo.label, data: dsInfo.data,
                             hidden: dsInfo.index === 5 ? true : dsInfo.hidden,
                             ...(dsInfo.fill !== undefined && { fill: dsInfo.fill, backgroundColor: dsInfo.backgroundColor }),
                         });
                    }
                });

                 applyBandVisibility(showBandsCheckbox.checked);

                chart.options.scales.x.min = extendedMinDay;
                chart.options.scales.x.max = extendedMaxDay;
                chart.options.scales.y.min = extendedMinPrice;
                chart.options.scales.y.max = extendedMaxPrice;
                chart.options.scales.x.afterBuildTicks = xAxisAfterBuildTicks;
                chart.update();

            } else {
                // --- Create New Chart ---
                chart = new Chart(ctx, {
                    data: {
                        datasets: [
                            { ...datasetDefaults, type: 'line', label: 'TAO Price', data: chartPriceDataPoints, backgroundColor: 'rgba(0, 0, 0, 0.05)', borderColor: 'rgba(0, 0, 0, 1)', borderWidth: 2, pointHoverRadius: 5, tension: 0.1 },
                            { ...datasetDefaults, label: '50th Percentile', data: medianLineData, ...orangeLineStyle, hidden: false },
                            { ...datasetDefaults, ...grayLineStyle, label: '1st Pctl', data: p1LineData },
                            { ...datasetDefaults, ...grayLineStyle, label: '99th Pctl', data: p99LineData },
                            { ...datasetDefaults, ...grayLineStyle, label: '20th Pctl', data: p20LineData, hidden: true },
                            { ...datasetDefaults, ...grayLineStyle, label: '50th Pctl (Hidden)', data: medianLineData, hidden: true },
                            { ...datasetDefaults, ...grayLineStyle, label: '80th Pctl', data: p80LineData, hidden: true },
                            { ...fillDatasetDefaults, label: 'Discount Band (P1-P20)', data: p20LineData, fill: 2, backgroundColor: blueFillColor },
                            { ...fillDatasetDefaults, label: 'Value Band (P20-P50)', data: medianLineData, fill: 4, backgroundColor: greenFillColor },
                            { ...fillDatasetDefaults, label: 'Expensive Band (P50-P80)', data: p80LineData, fill: 1, backgroundColor: yellowFillColor },
                            { ...fillDatasetDefaults, label: 'Bubble Band (P80-P99)', data: p99LineData, fill: 6, backgroundColor: redFillColor },
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#374151', usePointStyle: true, boxWidth: 30, boxHeight: 12,
                                    filter: (item) => !item.text.includes('Band') && item.datasetIndex !== 5,
                                }
                            },
                            tooltip: {
                                callbacks: {
                                     title: (tooltipItems) => {
                                         if (tooltipItems.length > 0) {
                                             const item = tooltipItems[0];
                                             const dayNumber = item.parsed.x; // This is the x-value on the chart
                                             
                                             const { activeDayOffset } = activeModelParams;
                                             let targetDayIndex = dayNumber - activeDayOffset;
                                             
                                             let dataPoint = baseData.find(p => p.dayIndex === Math.round(targetDayIndex));
                                             
                                             if (!dataPoint) {
                                                // Fallback for projected points: find closest
                                                dataPoint = baseData.reduce((prev, curr) => {
                                                    return (Math.abs(curr.dayIndex - targetDayIndex) < Math.abs(prev.dayIndex - targetDayIndex) ? curr : prev);
                                                });
                                             }

                                             if (dataPoint) {
                                                 const date = new Date(dataPoint.time);
                                                 return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
                                             }

                                             return `Day ~${targetDayIndex.toFixed(0)}`;
                                 }
                                         return '';
                                     },
                                     label: (context) => {
                                         if (context.dataset.label.includes('Band') || context.datasetIndex === 5) return null;
                                         return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                                     }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic', min: extendedMinDay, max: extendedMaxDay,
                                title: { display: true, text: `Time (Log Scale)`, color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563', autoSkip: false,
                                    callback: function(value) {
                                        const tick = this.getTicks().find(t => t.value === value);
                                        return tick ? tick.label : null;
                                    }
                                },
                                afterBuildTicks: xAxisAfterBuildTicks, 
                                grid: { color: 'rgba(0, 0, 0, 0.1)' }
                            },
                            y: {
                                type: 'logarithmic', min: extendedMinPrice, max: extendedMaxPrice,
                                title: { display: true, text: 'Price (Log Scale)', color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563',
                                    callback: function(value, index, ticks) {
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return `$${value.toLocaleString()}`;
                                        }
                                        return ''; 
                                    }
                                },
                                grid: { 
                                    color: function(context) {
                                        const value = context.tick.value;
                                        if (value <= 0) return 'rgba(0, 0, 0, 0.1)'; 
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return 'rgba(0, 0, 0, 0.1)'; 
                                        } else {
                                            return 'rgba(0, 0, 0, 0.05)';
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // --- 6. FINAL EVENT LISTENERS ---
            showBandsContainer.classList.remove('hidden');
            showBandsCheckbox.removeEventListener('change', handleBandToggle);
            showBandsCheckbox.addEventListener('change', handleBandToggle);

            useOptimalOffsetCheckbox.removeEventListener('change', createOrUpdateChart);
            useOptimalOffsetCheckbox.addEventListener('change', createOrUpdateChart);

            applyBandVisibility(showBandsCheckbox.checked);
            if(chart) chart.update('none'); 
        }

        /**
         * Event handler for the "Show Bands" checkbox.
         */
        function handleBandToggle() {
             if (!chart) return;
             applyBandVisibility(showBandsCheckbox.checked);
             chart.update();
        }

        /**
         * Toggles visibility and styles for band datasets.
         */
        function applyBandVisibility(showBands) {
             if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length < 11) {
                 console.error("Chart or datasets not fully initialized for applyBandVisibility.");
                 return;
             }
             const mainMedianIndex = 1;
             const p1Index = 2; const p99Index = 3;
             const p20Index = 4; const redundantP50Index = 5; const p80Index = 6;
             const fillIndices = [7, 8, 9, 10];

             if (chart.data.datasets[0]) chart.setDatasetVisibility(0, true); // Price
             if (chart.data.datasets[mainMedianIndex]) chart.setDatasetVisibility(mainMedianIndex, true);
             if (chart.data.datasets[redundantP50Index]) chart.setDatasetVisibility(redundantP50Index, false); // Always hidden

             if (showBands) {
                 const styleToApply = grayFineLineStyle;
                 if (chart.data.datasets[p1Index]) { chart.setDatasetVisibility(p1Index, true); Object.assign(chart.data.datasets[p1Index], styleToApply); }
                 if (chart.data.datasets[p99Index]) { chart.setDatasetVisibility(p99Index, true); Object.assign(chart.data.datasets[p99Index], styleToApply); }
                 if (chart.data.datasets[p20Index]) { chart.setDatasetVisibility(p20Index, true); Object.assign(chart.data.datasets[p20Index], styleToApply); }
                 if (chart.data.datasets[p80Index]) { chart.setDatasetVisibility(p80Index, true); Object.assign(chart.data.datasets[p80Index], styleToApply); }
                 
                 fillIndices.forEach(index => { if (chart.data.datasets[index]) chart.setDatasetVisibility(index, true); });
                 const medianDataset = chart.data.datasets[mainMedianIndex];
                 if (medianDataset) Object.assign(medianDataset, grayFineLineStyle);

             } else {
                 const styleToApply = grayDashedLineStyle; 
                 if (chart.data.datasets[p1Index]) { chart.setDatasetVisibility(p1Index, true); Object.assign(chart.data.datasets[p1Index], styleToApply); }
                 if (chart.data.datasets[p99Index]) { chart.setDatasetVisibility(p99Index, true); Object.assign(chart.data.datasets[p99Index], styleToApply); }
                 if (chart.data.datasets[p20Index]) { chart.setDatasetVisibility(p20Index, false); Object.assign(chart.data.datasets[p20Index], styleToApply); }
                 if (chart.data.datasets[p80Index]) { chart.setDatasetVisibility(p80Index, false); Object.assign(chart.data.datasets[p80Index], styleToApply); }

                 fillIndices.forEach(index => { if (chart.data.datasets[index]) chart.setDatasetVisibility(index, false); });
                 const medianDataset = chart.data.datasets[mainMedianIndex];
                 if (medianDataset) Object.assign(medianDataset, orangeLineStyle);
             }
        }
 
        /**
         * Calculates R-squared (coefficient of determination) for the log-log regression.
         */
        function calculateRSquared(data, slope, intercept) {
            let ss_tot = 0, ss_res = 0, y_mean = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length < 2) return 0;

            validData.forEach(p => y_mean += Math.log10(p.y));
            y_mean /= validData.length;

            validData.forEach(p => {
                const logY = Math.log10(p.y);
                const logX = Math.log10(p.x);
                const predictedLogY = slope * logX + intercept;
                ss_tot += Math.pow(logY - y_mean, 2);
                ss_res += Math.pow(logY - predictedLogY, 2);
            });
             return ss_tot === 0 ? 1 : Math.max(0, 1 - (ss_res / ss_tot)); 
        }
 
        /**
         * Calculates and displays future price projections in the floating table.
         * This function now relies on the global activeModelParams.
         */
        function calculateProjections(baseData, modelParams, tableElement) {
            if (!baseData || baseData.length === 0 || !tableElement || !modelParams) {
                if(tableElement) tableElement.classList.add('hidden');
                return;
            }

            const { slope, meanIntercept, modelType, activeDayOffset } = modelParams;

            // 1. Get the reference date and dayIndex from the *first data point* in the full dataset
            const firstDataPointDate = new Date(baseData[0].time);
            const firstDayIndex = baseData[0].dayIndex; // e.g., 1
            
            // 2. Define target dates dynamically
            const today = new Date();
            const currentYear = today.getFullYear();
            const targetDates = [
                { label: "Today", date: today },
                { label: `${currentYear + 1}`, date: new Date(currentYear + 1, 0, 1) },
                { label: `${currentYear + 2}`, date: new Date(currentYear + 2, 0, 1) },
                { label: `${currentYear + 3}`, date: new Date(currentYear + 3, 0, 1) }
            ];

            const MS_PER_DAY = 1000 * 60 * 60 * 24;

            // 3. Helper function to get the target dayIndex (relative to the first day in data)
            const getDayIndex = (targetDate) => {
                const diffTime = targetDate.getTime() - firstDataPointDate.getTime();
                const diffDays = Math.round(diffTime / MS_PER_DAY);
                return firstDayIndex + diffDays;
            };

            // 4. Helper function to calculate price using the active model's formula
            const calculatePrice = (targetDayIndex) => {
                let dayForLog;
                // For offset models, we add the offset
                dayForLog = targetDayIndex + activeDayOffset;

                if (dayForLog <= 0) return NaN; // Can't log(0) or negative
                const logX = Math.log10(dayForLog);
                return Math.pow(10, slope * logX + meanIntercept);
            };

            // 5. Build HTML
            let tableHtml = `
                <h3>
                    <span>Fair Value</span>
                    <button onclick="document.getElementById('projectionTable').style.display='none'" type="button" title="Close">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </h3>`;

            // 6. Calculate and build HTML for each price
            targetDates.forEach(item => {
                const targetDayIndex = getDayIndex(item.date); // e.g., 800
                const projectedPrice = calculatePrice(targetDayIndex);
                
                const priceString = isNaN(projectedPrice) ? "N/A" : `$${projectedPrice.toFixed(2)}`;
                const label = item.label;

                tableHtml += `
                    <div>
                        <span>${label}</span>
                        <span>${priceString}</span>
                    </div>
                `;
            });

            tableElement.innerHTML = tableHtml;
            tableElement.style.display = ''; 
            tableElement.classList.remove('hidden');
        }
 
        // --- FULLSCREEN & MOBILE VIEW LOGIC ---

        const mainContainer = document.getElementById('mainContainer');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fsIconEnter = document.getElementById('fsIconEnter');
        const fsIconExit = document.getElementById('fsIconExit');
        const headerElement = document.querySelector('header');
        const bottomBarElement = document.getElementById('bottomModelBar');
        const topBarElement = document.getElementById('topStatusBar');
        const chartCardElement = document.getElementById('chartCard');

        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (mainContainer.requestFullscreen) mainContainer.requestFullscreen().catch(err => console.error(`Error entering fullscreen: ${err.message}`));
                else if (mainContainer.webkitRequestFullscreen) mainContainer.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen().catch(err => console.error(`Error exiting fullscreen: ${err.message}`));
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        function handleFullscreenChange() {
             requestAnimationFrame(() => { 
                 const isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                 const isMobile = window.innerWidth < 640;
                 const isLandscape = screen.orientation ? screen.orientation.type.includes('landscape') : window.innerWidth > window.innerHeight;

                 if (isInFullscreen) {
                     fsIconEnter.classList.add('hidden');
                     fsIconExit.classList.remove('hidden');
                     fullscreenBtn.setAttribute('title', 'Exit Fullscreen');
                 } else {
                     fsIconEnter.classList.remove('hidden');
                     fsIconExit.classList.add('hidden');
                     fullscreenBtn.setAttribute('title', 'Enter Fullscreen');
                 }

                 if (headerElement) headerElement.style.display = '';
                 if (bottomBarElement) bottomBarElement.style.display = '';
                 if (topBarElement) topBarElement.style.display = '';
                 if (chartCardElement) chartCardElement.style.padding = '';

                 if (isInFullscreen && isMobile && isLandscape) {
                     if (headerElement) headerElement.style.display = 'none';
                     if (bottomBarElement) bottomBarElement.style.display = 'none';
                     if (chartCardElement) chartCardElement.style.padding = '0';
                 }

                  if (chart) {
                     setTimeout(() => {
                         requestAnimationFrame(() => {
                             if (chart) chart.resize();
                         });
                     }, 50); 
                  }
             });
        }
 
        /**
         * NEW: Recalculates Y-axis limits based on the current X-axis view.
         */
        function refitYAxis() {
            if (!chart || !priceData || priceData.length === 0) return;

            const currentXMin = chart.options.scales.x.min;
            const currentXMax = chart.options.scales.x.max;

            // 1. Filter data to visible range
            const visibleData = priceData.filter(p => p.x >= currentXMin && p.x <= currentXMax);

            if (visibleData.length < 2) {
                 // Not enough data to refit, just leave the Y-axis as is.
                 return; 
            }

            // 2. Find min/max price in visible range
            const prices = visibleData.map(p => p.y);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);

            // 3. Recalculate Y-axis limits with padding
            const logMinPrice = Math.log10(minPrice);
            const logMaxPrice = Math.log10(maxPrice);
            const logPriceRange = logMaxPrice - logMinPrice;

            let extendedMinPrice, extendedMaxPrice;
            
            // --- NEW DYNAMIC PADDING LOGIC ---
            // Calculate current X-axis zoom ratio
            const currentLogRangeX = Math.log10(currentXMax) - Math.log10(currentXMin);
            const originalLogRangeX = Math.log10(originalExtendedMaxDay) - Math.log10(originalExtendedMinDay);
            let zoomRatio = 1.0; // Default to fully zoomed out
            if (originalLogRangeX > 0) {
                 zoomRatio = currentLogRangeX / originalLogRangeX;
                 if (zoomRatio > 1.0) zoomRatio = 1.0;
                 if (zoomRatio < 0.0) zoomRatio = 0.0;
            }
            
            // Interpolate top padding between 10% (zoomed in) and 40% (zoomed out)
            const minTopPadding = Y_AXIS_TOP_PADDING_MIN; // USE CONSTANT
            const maxTopPadding = Y_AXIS_TOP_PADDING_MAX; // USE CONSTANT
            const dynamicTopPadding = minTopPadding + (maxTopPadding - minTopPadding) * zoomRatio;
            const bottomPadding = Y_AXIS_BOTTOM_PADDING; // USE CONSTANT
            // --- END NEW LOGIC ---
            
            if (logPriceRange > 0) {
                 extendedMinPrice = Math.pow(10, logMinPrice - logPriceRange * bottomPadding); // 10% padding below
                 extendedMaxPrice = Math.pow(10, logMaxPrice + logPriceRange * dynamicTopPadding); // DYNAMIC padding above
            } else {
                // Fallback for single point or flat line
                 extendedMinPrice = minPrice * 0.9;
                 extendedMaxPrice = maxPrice * 1.1;
            }

            // 4. Apply new Y-axis limits
            chart.options.scales.y.min = extendedMinPrice;
            chart.options.scales.y.max = extendedMaxPrice;
        }

        /**
         * NEW: Handles zooming the X-axis with the mouse wheel.
         */
        function handleWheelZoom(event) {
            if (!chart || !priceData || priceData.length === 0) return;
            event.preventDefault(); // Stop the page from scrolling
 
            const chartArea = chart.chartArea;
            if (!chartArea) return;

            // 1. Get cursor position and its log-scale value
            const rect = event.target.getBoundingClientRect();
            let cursorX = event.clientX - rect.left;
            
            // NEW: Clamp cursorX to the chartArea boundaries
            if (cursorX < chartArea.left) {
                cursorX = chartArea.left;
            }
            if (cursorX > chartArea.right) {
                cursorX = chartArea.right;
            }

            const currentMinLog = Math.log10(chart.options.scales.x.min);
            const currentMaxLog = Math.log10(chart.options.scales.x.max);
            const currentLogRange = currentMaxLog - currentMinLog;
            
            // Calculate what percentage the cursor is across the chart
            const cursorPct = (chartArea.right - chartArea.left > 0) ? (cursorX - chartArea.left) / (chartArea.right - chartArea.left) : 0;
            
            // Find the log value at the cursor
            const logAtCursor = currentMinLog + (currentLogRange * cursorPct);

            // 2. Calculate new range
            // zoomDirection will be < 1 for zooming in, > 1 for zooming out
            const zoomDirection = event.deltaY < 0 ? (1 - ZOOM_FACTOR) : (1 + ZOOM_FACTOR);
            let newLogRange = currentLogRange * zoomDirection;

            // 3. Boundary checks for zoom level
            const minLogRange = 0.1; // Don't allow zoom to be *too* tight
            const maxLogRange = Math.log10(originalExtendedMaxDay) - Math.log10(originalExtendedMinDay);
            
            if (newLogRange < minLogRange) newLogRange = minLogRange;
            if (newLogRange > maxLogRange) newLogRange = maxLogRange;

            // 4. Calculate new min/max based on cursor position
            let newLogMin = logAtCursor - (newLogRange * cursorPct);
            let newLogMax = newLogMin + newLogRange;
            
            // 5. Boundary checks for panning
            const originalMinLog = Math.log10(originalExtendedMinDay);
            const originalMaxLog = Math.log10(originalExtendedMaxDay);

            if (newLogMin < originalMinLog) {
                newLogMin = originalMinLog;
                newLogMax = newLogMin + newLogRange;
            }
            if (newLogMax > originalMaxLog) {
                newLogMax = originalMaxLog;
                newLogMin = newLogMax - newLogRange;
            }
            
            // Ensure min is still less than max after all adjustments
            if (newLogMin < originalMinLog) newLogMin = originalMinLog;


            // 6. Apply new X-axis
            chart.options.scales.x.min = Math.pow(10, newLogMin);
            chart.options.scales.x.max = Math.pow(10, newLogMax);

            // 7. Refit Y-axis
            refitYAxis();

            // 8. Update chart
            chart.update('none');
        }
 
        /**
         * NEW: Handles starting the pan action.
         */
        function handlePanStart(event) {
            if (!chart) return;
            isPanning = true;
            panStartX = event.clientX;
            panStartMin = chart.options.scales.x.min;
            panStartLogRange = Math.log10(chart.options.scales.x.max) - Math.log10(panStartMin);
            event.target.style.cursor = 'move'; // CHANGED from 'grabbing'
        }

        /**
         * NEW: Handles moving the chart during a pan.
         */
        function handlePanMove(event) {
            if (!chart || !isPanning) return;

            const chartArea = chart.chartArea;
            if (!chartArea) return;

            // 1. Calculate how many pixels per "log unit"
            const currentMinLog = Math.log10(chart.options.scales.x.min);
            const currentMaxLog = Math.log10(chart.options.scales.x.max);
            const logRange = currentMaxLog - currentMinLog;
            const pixelRange = chartArea.right - chartArea.left;
            if (pixelRange <= 0) return;
            const logPerPixel = logRange / pixelRange;

            // 2. Calculate the change in log value
            const deltaX = event.clientX - panStartX;
            const logDelta = deltaX * logPerPixel;

            // 3. Calculate new min
            let newLogMin = Math.log10(panStartMin) - logDelta;
            
            // 4. Calculate new max based on the original range
            let newLogMax = newLogMin + panStartLogRange;
            
            // 5. Boundary checks
            if (Math.pow(10, newLogMin) < originalExtendedMinDay) {
                newLogMin = Math.log10(originalExtendedMinDay);
                newLogMax = newLogMin + panStartLogRange;
            }
            if (Math.pow(10, newLogMax) > originalExtendedMaxDay) {
                newLogMax = Math.log10(originalExtendedMaxDay);
                newLogMin = newLogMax - panStartLogRange;
            }
            
            // 6. Apply new X-axis
            chart.options.scales.x.min = Math.pow(10, newLogMin);
            chart.options.scales.x.max = Math.pow(10, newLogMax);

            // 7. Refit Y-axis
            refitYAxis();

            // 8. Update chart
            chart.update('none');
        }

        /**
         * NEW: Handles ending the pan action.
         */
        function handlePanEnd(event) {
            if (!chart) return;
            isPanning = false;
            event.target.style.cursor = 'move'; // CHANGED from 'grab'
        }

        // --- Event Listeners ---
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange); // Safari
        window.addEventListener('resize', handleFullscreenChange);
         if (screen.orientation) {
             screen.orientation.addEventListener('change', handleFullscreenChange);
         } else {
             window.addEventListener('orientationchange', handleFullscreenChange); // Older mobile
         }

        // Initial load
        window.onload = () => {
            createOrUpdateChart();
            // Add listener for model selection
            useOptimalOffsetCheckbox.addEventListener('change', createOrUpdateChart);
            
            // NEW: Add wheel zoom listener to the canvas
            const canvas = document.getElementById('powerLawChart');
            if (canvas) {
                canvas.addEventListener('wheel', handleWheelZoom, { passive: false });
                
                // NEW: Add pan listeners
                canvas.addEventListener('mousedown', handlePanStart);
                canvas.addEventListener('mousemove', handlePanMove);
                canvas.addEventListener('mouseup', handlePanEnd);
                canvas.addEventListener('mouseleave', handlePanEnd);
                canvas.style.cursor = 'move'; // NEW: Set initial cursor to 'move'
                
                // NEW: Add mouseenter to reset cursor just in case
                canvas.addEventListener('mouseenter', (e) => {
                    e.target.style.cursor = isPanning ? 'move' : 'move';
                });
            }

            setTimeout(handleFullscreenChange, 150); // Initial check for mobile state
        }
    </script>
 
</body>
</html>

