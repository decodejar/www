<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAO Tensor Law Model</title>
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Internal Styles -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Loader animation */
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ff6d00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Colored status dot */
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        /* --- Fullscreen CSS Logic --- */
        
        body:has(#mainContainer:fullscreen) { display: block; }
        #mainContainer:fullscreen {
            width: 100vw; height: 100vh; max-width: none !important;
            border-radius: 0 !important; display: flex; flex-direction: column;
        }
        #mainContainer:fullscreen #chartCard { flex-grow: 1; display: flex; flex-direction: column; }
        #mainContainer:fullscreen #chartWrapper { height: 100% !important; flex-grow: 1; }
        body:has(#mainContainer:fullscreen) footer { display: none; }

        /* --- Mobile Fullscreen Optimizations --- */
        @media (max-width: 639px) and (orientation: portrait) {
            #mainContainer:fullscreen #rotateOverlay { display: flex !important; }
            #mainContainer:fullscreen header,
            #mainContainer:fullscreen #topStatusBar,
            #mainContainer:fullscreen #chartCard,
            #mainContainer:fullscreen #bottomModelBar,
            #mainContainer:fullscreen #fullscreenBtn { display: none !important; }
        }
        #mainContainer.mobile-fullscreen-landscape header,
        #mainContainer.mobile-fullscreen-landscape #bottomModelBar { display: none !important; }
        #mainContainer.mobile-fullscreen-landscape #chartCard { padding: 0 !important; }
        #mainContainer.mobile-fullscreen-landscape #topStatusBar { display: flex !important; }
        /* --- END: Mobile Fullscreen Optimizations --- */

        /* --- Projection Table Styles --- */
        #projectionTable {
            position: absolute; top: 12%; left: 10%; z-index: 5;
            background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(4px);
            border-radius: 0.5rem; padding: 0.5rem 0.75rem; font-size: 0.75rem;
            line-height: 1.15rem; color: #374151;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        #projectionTable h3 {
            font-weight: 600; color: #1f2937; margin-bottom: 0.25rem;
            border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 0.25rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        #projectionTable div { display: flex; justify-content: space-between; }
        #projectionTable div span:first-child { margin-right: 1.25rem; color: #4b5563; }
        #projectionTable div span:last-child { font-weight: 500; color: #1f2937; }
        #projectionTable h3 button {
            margin-left: 0.5rem; color: #9ca3af; cursor: pointer;
            background: none; border: none; padding: 0; line-height: 1;
        }
         #projectionTable h3 button:hover { color: #374151; }
        /* --- END: Projection Table Styles --- */
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center h-screen p-2">

    <!-- Main application container -->
    <div id="mainContainer" class="w-full flex-grow max-w-[1920px] max-h-[1080px] min-h-[30rem] flex flex-col bg-white rounded-lg shadow-xl p-2 sm:p-3 md:p-4 relative">

        <!-- Mobile Rotate Overlay -->
        <div id="rotateOverlay" class="hidden absolute inset-0 w-full h-full bg-white/95 z-50 flex-col items-center justify-center text-center p-8">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 text-gray-600 mb-4 animate-pulse">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.992 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
            <h2 class="text-2xl font-semibold text-gray-800 mb-2">Please Rotate Your Device</h2>
            <p class="text-gray-600">This chart is best viewed in landscape mode.</p>
        </div>

        <!-- Fullscreen toggle button -->
        <button id="fullscreenBtn" onclick="toggleFullScreen()" class="absolute top-4 right-4 sm:top-6 sm:right-6 text-gray-400 hover:text-gray-800 transition-colors z-20 p-1 rounded-full hover:bg-gray-100" title="Toggle Fullscreen">
            <svg id="fsIconEnter" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m4.5 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
            </svg>
            <svg id="fsIconExit" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 hidden">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 9L3.75 3.75M9 9h4.5m-4.5 0v4.5m0-4.5L3.75 3.75M9 15l-5.25 5.25M9 15h4.5m-4.5 0v-4.5m0 4.5l-5.25 5.25M15 9l5.25-5.25M15 9h-4.5m4.5 0v4.5m0-4.5l5.25-5.25M15 15l5.25 5.25M15 15h-4.5m4.5 0v-4.5m0 4.5l5.25 5.25" />
            </svg>
        </button>
        
        <!-- Page Header -->
        <header class="text-center mb-3">
            <h1 class="text-xl sm:text-2xl md:text-3xl text-gray-900">TAO Tensor Law Model</h1>
        </header>

        <!-- Top Status Bar: Data status, price, bands toggle -->
        <div id="topStatusBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mb-2 text-sm text-gray-600 px-4">
             <div id="statusDiv" class="flex items-center">
                 <span class="status-dot bg-yellow-400"></span>Loading latest data...
             </div>
             <div id="lastUpdateDiv" class="hidden sm:block"></div>
             <div id="lastPriceDiv" class="hidden sm:block"></div>
             <div id="priceZoneDiv" class="flex items-center hidden sm:block"></div>
             
             <!-- Bands Toggle Checkbox -->
             <div id="showBandsContainer" class="flex items-center hidden">
                 <input type="checkbox" id="showBandsCheckbox" class="mr-1.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                 <label for="showBandsCheckbox" class="cursor-pointer mr-1">Bands&nbsp;</label>
                 <span title="Blue: Discount (P1-P20), Green: Value (P20-P50), Yellow: Expensive (P50-P80), Red: Bubble (P80-P99)" class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
             </div>
        </div>

        <!-- Chart Card: Contains loader and canvas wrapper -->
        <div id="chartCard" class="bg-white p-2 rounded-lg relative flex-grow flex flex-col min-h-0">
            <!-- Loading Spinner -->
            <div id="loader" class="absolute inset-0 bg-white/80 flex items-center justify-center z-10">
                <div class="loader"></div>
            </div>
            <!-- Canvas Wrapper: Scales to fill parent card -->
            <div id="chartWrapper" class="relative flex-grow min-h-0">
                <div id="projectionTable" class="hidden"></div>
                <canvas id="powerLawChart"></canvas>
            </div>

            <!-- Bottom Model Info Bar: Model parameters -->
            <div id="bottomModelBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mt-2 text-sm text-gray-600">
                <!-- Model Selection Dropdown -->
                <div class="flex items-center">
                    <label for="modelSelect" class="mr-1.5"><strong>Model:</strong></label>
                    <select id="modelSelect" class="text-sm rounded border-gray-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="hardcoded" selected>Default Offset (P/L)</option>
                        <option value="optimalOffset">Optimal Offset (P/L)</option>
                        <option value="truncation">Optimal Truncation (P/L)</option>
                        <option value="hardcodedExponential">Default Offset (Exp)</option>
                        <option value="optimalExponentialOffset">Optimal Offset (Exp)</option>
                        <option value="truncationExponential">Optimal Truncation (Exp)</option>
                    </select>
                </div>
                <div id="growthExponentDiv"></div>
                <div id="modelParamDiv"></div> 
                <div id="modelFitDiv"></div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="text-center p-1 mt-2">
        <p class="text-gray-600 text-xs">&copy; 2025 <a href="https://decodejar.com" target="_blank" rel="noopener noreferrer" class="hover:text-indigo-500 transition-colors">DECODEJAR.COM</a>. All Rights Reserved. Disclaimer: This tool is for informational and research purposes only and does not constitute financial or trading advice. Past performance is not indicative of future results.</p>
    </footer>

<script>
        /*
         * TAO Tensor Law Model & Regression Logic
         * Copyright (c) 2025 Decodejar.com. All Rights Reserved.
         */

        // --- Global Element References ---
        const growthExponentDiv = document.getElementById('growthExponentDiv');
        const modelFitDiv = document.getElementById('modelFitDiv');
        const loader = document.getElementById('loader');
        const statusDiv = document.getElementById('statusDiv');
        const lastUpdateDiv = document.getElementById('lastUpdateDiv');
        const lastPriceDiv = document.getElementById('lastPriceDiv');
        const priceZoneDiv = document.getElementById('priceZoneDiv');
        const ctx = document.getElementById('powerLawChart').getContext('2d');
        const modelParamDiv = document.getElementById('modelParamDiv');
        const showBandsContainer = document.getElementById('showBandsContainer');
        const showBandsCheckbox = document.getElementById('showBandsCheckbox');
        const projectionTable = document.getElementById('projectionTable');
        const modelSelect = document.getElementById('modelSelect');

        // --- Chart Configuration ---
        const HARDCODED_OFFSET = 75; 
        const MIN_DATA_POINTS_FOR_MODEL = 30; // Min data points for truncation/exponential models
        let chart; // Global chart instance
        let activeModelParams = {}; // Stores params of the active model

        // Band Fill Colors
        const blueFillColor = 'rgba(147, 197, 253, 0.1)';
        const greenFillColor = 'rgba(34, 197, 94, 0.1)';
        const yellowFillColor = 'rgba(250, 204, 21, 0.1)';
        const redFillColor = 'rgba(239, 68, 68, 0.1)';

        // Reusable Line Styles
        const grayLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 1 };
        const orangeLineStyle = { borderColor: '#ff6d00', borderWidth: 2 };
        const grayDashedLineStyle = { borderColor: 'rgba(156, 163, 175, 0.9)', borderWidth: 1, borderDash: [2, 2] };
        const grayFineLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 0.5, borderDash: [] };

        /**
         * Fetches and parses price data from JSON file.
         */
        async function loadPriceData() {
            try {
                const response = await fetch(`./price_data.json?t=${new Date().getTime()}`);
                if (!response.ok) throw new Error(`Failed to load data file: ${response.statusText}`);
                const data = await response.json();
                 if (!Array.isArray(data)) throw new Error("Invalid data format in JSON file");
                return data.map((p, i) => ({ time: p[0] * 1000, dayIndex: i + 1, y: p[1] })).filter(p => p.y > 0);
            } catch (error) {
                console.error("Error loading price data:", error);
                statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>Error loading data. Check console.`;
                loader.style.display = 'none';
                return null;
            }
        }

        /**
         * Performs linear regression on log(y) vs log(x). (Power Law)
         */
        function powerLawRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            const n = validData.length;
            if (n < 2) return { slope: 0, intercept: 0, n: 0 }; 
            
            for (const { x, y } of validData) {
                const logX = Math.log10(x);
                const logY = Math.log10(y);
                sumX += logX; sumY += logY; sumXY += logX * logY; sumX2 += logX * logX;
            }

            const denominator = (n * sumX2 - sumX * sumX);
            if (denominator === 0) return { slope: 0, intercept: 0, n: n }; 
            
            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept, n: n };
        }
        
        /**
         * Performs linear regression on log(y) vs x. (Exponential)
         */
        function exponentialRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const validData = data.filter(p => p.y > 0); // x can be 0 or anything
            const n = validData.length;
            if (n < 2) return { slope: 0, intercept: 0, n: 0 }; 

            for (const { x, y } of validData) {
                // x is LINEAR, y is LOG
                const logY = Math.log10(y);
                sumX += x; sumY += logY; sumXY += x * logY; sumX2 += x * x;
            }

            const denominator = (n * sumX2 - sumX * sumX);
            if (denominator === 0) return { slope: 0, intercept: 0, n: n };
            
            const slope = (n * sumXY - sumX * sumY) / denominator; // This is k
            const intercept = (sumY - slope * sumX) / n; // This is log10(C)
            return { slope, intercept, n: n };
        }

        /**
         * Calculates sorted residuals (logY - predictedLogY) from the mean regression line.
         * Works for both power law and exponential, as both predict logY.
         */
        function calculateResiduals(data, slope, intercept, modelType) {
            const validData = data.filter(p => p.y > 0);
            if (validData.length === 0) return [];
            
            const isExponential = modelType.includes('Exponential');
            const getPredictedLogY = isExponential
                ? (p) => slope * p.x + intercept // x is linear
                : (p) => (p.x > 0) ? slope * Math.log10(p.x) + intercept : -Infinity; // x is log

            return validData.map(p => {
                const logY = Math.log10(p.y);
                const predictedLogY = getPredictedLogY(p);
                if (!isFinite(predictedLogY)) return -Infinity;
                return logY - predictedLogY;
            })
            .filter(isFinite) // Remove any -Infinity results from log(0)
            .sort((a, b) => a - b); 
        }

        /**
         * Gets a specific percentile value from a pre-sorted array of residuals.
         */
        function getPercentile(sortedResiduals, percentile) {
            if (!sortedResiduals || sortedResiduals.length === 0) return 0;
            const index = (percentile / 100) * (sortedResiduals.length - 1);
            const lowerIndex = Math.floor(index);
            const upperIndex = Math.ceil(index);
            
            if (lowerIndex === upperIndex) return sortedResiduals[lowerIndex];
            const weight = index - lowerIndex;
            return sortedResiduals[lowerIndex] * (1 - weight) + sortedResiduals[upperIndex] * weight;
        }

        /**
         * Calculates R-squared (coefficient of determination).
         * Works for both model types as it's based on logY.
         */
        function calculateRSquared(data, slope, intercept, modelType) {
            let ss_tot = 0, ss_res = 0, y_mean = 0;
            const validData = data.filter(p => p.y > 0);
            if (validData.length < 2) return 0;

            validData.forEach(p => y_mean += Math.log10(p.y));
            y_mean /= validData.length;

            const isExponential = modelType.includes('Exponential');
            const getPredictedLogY = isExponential
                ? (p) => slope * p.x + intercept
                : (p) => (p.x > 0) ? slope * Math.log10(p.x) + intercept : -Infinity;

            validData.forEach(p => {
                const logY = Math.log10(p.y);
                const predictedLogY = getPredictedLogY(p);
                if (!isFinite(predictedLogY)) return; // Skip invalid points

                ss_tot += Math.pow(logY - y_mean, 2);
                ss_res += Math.pow(logY - predictedLogY, 2);
            });
            return ss_tot === 0 ? 1 : Math.max(0, 1 - (ss_res / ss_tot));
        }

        /**
         * Finds the optimal day offset by testing a range of values. (Power Law)
         */
        function findOptimalOffset(baseData, minOffset = 1, maxOffset) {
            let bestOffset = -1;
            let bestRSquared = -Infinity;

            if (baseData.length < 2) return { optimalOffset: -1, bestFit: 0 };
            if (typeof maxOffset === 'undefined' || maxOffset < minOffset) maxOffset = baseData.length; 

            for (let offset = minOffset; offset <= maxOffset; offset++) {
                const offsetData = baseData.map(p => ({ x: p.dayIndex + offset, y: p.y }));
                const { slope, intercept, n } = powerLawRegression(offsetData);
                if (n < 2) continue;
                
                const rSquared = calculateRSquared(offsetData, slope, intercept, 'powerLaw');
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestOffset = offset;
                }
            }
            return { optimalOffset: bestOffset, bestFit: bestRSquared };
        }

        /**
         * NEW: Finds the optimal day offset by testing a range of values. (Exponential)
         */
        function findOptimalExponentialOffset(baseData, minOffset = 1, maxOffset) {
            let bestOffset = -1;
            let bestRSquared = -Infinity;

            if (baseData.length < 2) return { optimalOffset: -1, bestFit: 0 };
            if (typeof maxOffset === 'undefined' || maxOffset < minOffset) maxOffset = baseData.length; 

            for (let offset = minOffset; offset <= maxOffset; offset++) {
                const offsetData = baseData.map(p => ({ x: p.dayIndex + offset, y: p.y }));
                const { slope, intercept, n } = exponentialRegression(offsetData); // Changed
                if (n < 2) continue;
                
                const rSquared = calculateRSquared(offsetData, slope, intercept, 'exponential'); // Changed
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestOffset = offset;
                }
            }
            return { optimalOffset: bestOffset, bestFit: bestRSquared };
        }

        /**
         * Finds the optimal start day (truncation) for a Power Law model.
         */
        function findOptimalPowerLawTruncation(baseData) {
            let bestStartIndex = -1;
            let bestRSquared = -Infinity;
            let bestSlope = 0;
            let bestIntercept = 0;

            const maxStartIndex = baseData.length - MIN_DATA_POINTS_FOR_MODEL;
            if (maxStartIndex < 0) {
                return { bestStartIndex: 0, slope: 0, intercept: 0, bestFit: 0 };
            }

            for (let startIndex = 0; startIndex <= maxStartIndex; startIndex++) {
                const truncatedData = baseData.slice(startIndex);
                const regressionData = truncatedData.map(p => ({ x: p.dayIndex, y: p.y }));
                
                const { slope, intercept, n } = powerLawRegression(regressionData);
                if (n < 2) continue;

                const rSquared = calculateRSquared(regressionData, slope, intercept, 'powerLaw');
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestStartIndex = startIndex;
                    bestSlope = slope;
                    bestIntercept = intercept;
                }
            }
            return { bestStartIndex, slope: bestSlope, intercept: bestIntercept, bestFit: bestRSquared };
        }

        /**
         * Finds the optimal start day (truncation) for an Exponential model.
         */
        function findOptimalExponentialFit(baseData) {
            let bestStartIndex = -1;
            let bestRSquared = -Infinity;
            let bestSlope = 0;
            let bestIntercept = 0;

            const maxStartIndex = baseData.length - MIN_DATA_POINTS_FOR_MODEL;
            if (maxStartIndex < 0) {
                return { bestStartIndex: 0, slope: 0, intercept: 0, bestFit: 0 };
            }

            for (let startIndex = 0; startIndex <= maxStartIndex; startIndex++) {
                const truncatedData = baseData.slice(startIndex);
                const regressionData = truncatedData.map(p => ({ x: p.dayIndex, y: p.y }));
                
                const { slope, intercept, n } = exponentialRegression(regressionData);
                if (n < 2) continue;

                const rSquared = calculateRSquared(regressionData, slope, intercept, 'exponential');
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestStartIndex = startIndex;
                    bestSlope = slope;
                    bestIntercept = intercept;
                }
            }
            return { bestStartIndex, slope: bestSlope, intercept: bestIntercept, bestFit: bestRSquared };
        }


        /**
         * Main function to load data, run calculations, and create or update the chart.
         */
        async function createOrUpdateChart() {
            loader.style.display = 'flex';
            const baseData = await loadPriceData();

            if (!baseData || baseData.length === 0) {
                 if (!statusDiv.innerHTML.includes('Error')) {
                     statusDiv.innerHTML = `<span class="status-dot bg-red-500"></span>No valid data to display.`;
                 }
                 growthExponentDiv.innerHTML = '<strong>Exponent (α):</strong> N/A';
                 modelParamDiv.innerHTML = '<strong>Model:</strong> N/A';
                 modelFitDiv.innerHTML = '<strong>Fit (R²):</strong> N/A';
                 if (modelSelect) modelSelect.disabled = true;
                 showBandsContainer.classList.add('hidden');
                 loader.style.display = 'none';
                 return;
            }

            // --- 1. GET MODEL PARAMETERS BASED ON SELECTION ---
            const selectedModel = modelSelect.value;
            let priceData, slope, meanIntercept, rSquared;
            
            activeModelParams = {
                modelType: selectedModel, 
                activeDayOffset: 0, 
                truncationStartIndex: 0
            };

            const maxDaysInData = baseData.length > 0 ? baseData.length : 1;
            // Always find optimal values for comparison
            const { optimalOffset, bestFit: optimalOffsetRSquared } = findOptimalOffset(baseData, 1, maxDaysInData);
            const { optimalOffset: optimalExpOffset, bestFit: optimalExpOffsetRSquared } = findOptimalExponentialOffset(baseData, 1, maxDaysInData);


            switch (selectedModel) {
                case 'optimalOffset': {
                    activeModelParams.activeDayOffset = optimalOffset;
                    priceData = baseData.map(p => ({ ...p, x: p.dayIndex + optimalOffset }));
                    const regression = powerLawRegression(priceData);
                    slope = regression.slope;
                    meanIntercept = regression.intercept;
                    rSquared = optimalOffsetRSquared; 
                    modelParamDiv.innerHTML = `<strong>Offset:</strong> ${optimalOffset} (Optimal)`;
                    growthExponentDiv.innerHTML = `<strong>Exponent (α):</strong> ${slope.toFixed(3)}`;
                    break;
                }
                
                case 'hardcoded': {
                    activeModelParams.activeDayOffset = HARDCODED_OFFSET;
                    priceData = baseData.map(p => ({ ...p, x: p.dayIndex + HARDCODED_OFFSET }));
                    const regression = powerLawRegression(priceData);
                    slope = regression.slope;
                    meanIntercept = regression.intercept;
                    rSquared = calculateRSquared(priceData, slope, meanIntercept, 'powerLaw');
                    if (optimalOffset !== -1 && optimalOffset !== HARDCODED_OFFSET) {
                         modelParamDiv.innerHTML = `<strong>Offset:</strong> ${HARDCODED_OFFSET} | <strong>Optimal:</strong> ${optimalOffset} (R² ${optimalOffsetRSquared.toFixed(4)})`;
                    } else {
                         modelParamDiv.innerHTML = `<strong>Offset:</strong> ${HARDCODED_OFFSET}`;
                    }
                    growthExponentDiv.innerHTML = `<strong>Exponent (α):</strong> ${slope.toFixed(3)}`;
                    break;
                }
                
                case 'truncation': {
                    const { bestStartIndex, slope: truncSlope, intercept: truncIntercept, bestFit: truncRSquared } = findOptimalPowerLawTruncation(baseData);
                    activeModelParams.truncationStartIndex = bestStartIndex;
                    priceData = baseData.slice(bestStartIndex).map(p => ({ ...p, x: p.dayIndex }));
                    slope = truncSlope;
                    meanIntercept = truncIntercept;
                    rSquared = truncRSquared;
                    modelParamDiv.innerHTML = `<strong>Start Day:</strong> ${baseData[bestStartIndex].dayIndex} (Truncated)`;
                    growthExponentDiv.innerHTML = `<strong>Exponent (α):</strong> ${slope.toFixed(3)}`;
                    break;
                }

                case 'optimalExponentialOffset': {
                    activeModelParams.activeDayOffset = optimalExpOffset;
                    priceData = baseData.map(p => ({ ...p, x: p.dayIndex + optimalExpOffset }));
                    const regression = exponentialRegression(priceData);
                    slope = regression.slope;
                    meanIntercept = regression.intercept;
                    rSquared = optimalExpOffsetRSquared;
                    modelParamDiv.innerHTML = `<strong>Offset:</strong> ${optimalExpOffset} (Optimal Exp.)`;
                    growthExponentDiv.innerHTML = `<strong>Growth (k):</strong> ${slope.toFixed(5)}`;
                    break;
                }

                case 'hardcodedExponential': {
                    activeModelParams.activeDayOffset = HARDCODED_OFFSET;
                    priceData = baseData.map(p => ({ ...p, x: p.dayIndex + HARDCODED_OFFSET }));
                    const regression = exponentialRegression(priceData);
                    slope = regression.slope;
                    meanIntercept = regression.intercept;
                    rSquared = calculateRSquared(priceData, slope, meanIntercept, 'exponential');
                    if (optimalExpOffset !== -1 && optimalExpOffset !== HARDCODED_OFFSET) {
                         modelParamDiv.innerHTML = `<strong>Offset:</strong> ${HARDCODED_OFFSET} | <strong>Optimal:</strong> ${optimalExpOffset} (R² ${optimalExpOffsetRSquared.toFixed(4)})`;
                    } else {
                         modelParamDiv.innerHTML = `<strong>Offset:</strong> ${HARDCODED_OFFSET}`;
                    }
                    growthExponentDiv.innerHTML = `<strong>Growth (k):</strong> ${slope.toFixed(5)}`;
                    break;
                }
                
                case 'truncationExponential': { 
                    const { bestStartIndex, slope: expSlope, intercept: expIntercept, bestFit: expRSquared } = findOptimalExponentialFit(baseData);
                    activeModelParams.truncationStartIndex = bestStartIndex;
                    priceData = baseData.slice(bestStartIndex).map(p => ({ ...p, x: p.dayIndex }));
                    slope = expSlope; 
                    meanIntercept = expIntercept; 
                    rSquared = expRSquared;
                    modelParamDiv.innerHTML = `<strong>Start Day:</strong> ${baseData[bestStartIndex].dayIndex} (Truncated)`;
                    growthExponentDiv.innerHTML = `<strong>Growth (k):</strong> ${slope.toFixed(5)}`; 
                    break;
                }
            }
            
            activeModelParams.slope = slope;
            activeModelParams.meanIntercept = meanIntercept;

            // --- 2. UPDATE UI & CALCULATE AXES (using model data) ---
            if (modelSelect) modelSelect.disabled = false;
            
            const lastDataPoint = priceData[priceData.length - 1];
            const lastTimestamp = baseData[baseData.length - 1].time;
            const lastUpdateDate = new Date(lastTimestamp).toLocaleDateString(undefined, {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            statusDiv.innerHTML = `<span class="status-dot bg-green-500"></span>Data Loaded`;
            lastUpdateDiv.innerHTML = `<strong>Updated:</strong> ${lastUpdateDate}`;
            lastPriceDiv.innerHTML = `<strong>Price:</strong> $${baseData[baseData.length - 1].y.toFixed(2)}`;
            lastUpdateDiv.classList.remove('hidden');
            lastPriceDiv.classList.remove('hidden');

            const prices = priceData.map(p => p.y);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);

            // X-Axis Range (with projection)
            const n = priceData.length;
            const firstDayNum = priceData[0].x;
            const firstDayTime = priceData[0].time;
            const lastDayNum = lastDataPoint.x;
            const lastDayTime = lastDataPoint.time;

            const timeDuration = lastDayTime - firstDayTime;
            let extendedMinDay, extendedMaxDay;

            const isExponential = selectedModel.includes('Exponential');
            const isTruncation = selectedModel.includes('truncation'); 

            if (isExponential || isTruncation) { 
                // For linear-time models, project based on days
                const dayDuration = lastDayNum - firstDayNum;
                const projectionDays = dayDuration * 1; // 100% projection
                extendedMinDay = firstDayNum;
                extendedMaxDay = lastDayNum + projectionDays;
            } else {
                // For log-time (offset) models, project based on log-time
                const logDayDuration = Math.log10(lastDayNum) - Math.log10(firstDayNum);
                const projectedLogDay = Math.log10(lastDayNum) + logDayDuration * 1;
                extendedMinDay = firstDayNum;
                extendedMaxDay = Math.pow(10, projectedLogDay);
            }

            // Y-Axis Range (with padding)
            const logMinPrice = Math.log10(minPrice);
            const logMaxPrice = Math.log10(maxPrice);
            const logPriceRange = logMaxPrice - logMinPrice;
            const extendedMinPrice = logPriceRange > 0 ? Math.pow(10, logMinPrice - logPriceRange * 0.1) : minPrice * 0.9;
            const extendedMaxPrice = logPriceRange > 0 ? Math.pow(10, logMaxPrice + logPriceRange * 0.4) : maxPrice * 1.4;

            // --- 3. MODEL CALCULATIONS (using model data) ---
            const sortedResiduals = calculateResiduals(priceData, slope, meanIntercept, selectedModel);

            const medianResidual = getPercentile(sortedResiduals, 50);
            const p1Residual = getPercentile(sortedResiduals, 1);
            const p99Residual = getPercentile(sortedResiduals, 99);
            const p20Residual = getPercentile(sortedResiduals, 20);
            const p80Residual = getPercentile(sortedResiduals, 80);

            // Determine current price zone
            let lastLogX;
            if (isExponential) {
                lastLogX = lastDataPoint.x; // linear
            } else {
                lastLogX = Math.log10(lastDataPoint.x); // log
            }
            const lastLogY = Math.log10(lastDataPoint.y);
            
            const predictedLastLogY = isExponential
                ? slope * lastLogX + meanIntercept
                : slope * lastLogX + meanIntercept; 

            const lastResidual = lastLogY - predictedLastLogY;

            let priceZone = "";
            let priceZoneColor = "";
            if (lastResidual > p80Residual) { priceZone = "Bubble"; priceZoneColor = "bg-red-500"; }
            else if (lastResidual > medianResidual) { priceZone = "Expensive"; priceZoneColor = "bg-yellow-400"; }
            else if (lastResidual > p20Residual) { priceZone = "Value"; priceZoneColor = "bg-green-500"; }
            else { priceZone = "Discount"; priceZoneColor = "bg-blue-300"; }

            priceZoneDiv.innerHTML = `<span class="status-dot ${priceZoneColor}"></span><strong>Rating:</strong>&nbsp;${priceZone}`;
            priceZoneDiv.classList.remove('hidden');

            const medianIntercept = meanIntercept + medianResidual;
            const p1Intercept = meanIntercept + p1Residual;
            const p99Intercept = meanIntercept + p99Residual;
            const p20Intercept = meanIntercept + p20Residual;
            const p80Intercept = meanIntercept + p80Residual;

            // Call projection function (passes full baseData for date calculations)
            calculateProjections(baseData, activeModelParams, projectionTable);

            // --- Update Bottom Status Bar ---
            let fitColorClass = "";
            if (rSquared >= 0.9) fitColorClass = "bg-blue-300";
            else if (rSquared >= 0.7) fitColorClass = "bg-green-500";
            else if (rSquared >= 0.5) fitColorClass = "bg-yellow-400";
            else fitColorClass = "bg-red-500";
            modelFitDiv.innerHTML = `<span class="status-dot ${fitColorClass}"></span><strong>Fit (R²):</strong> ${rSquared.toFixed(4)}`;
            
            // --- 4. GENERATE CHART DATA ---
            const startIndex = extendedMinDay;
            const endIndex = extendedMaxDay;

            // This function creates the two points for the percentile lines
            const calculateLinePoints = (intercept) => {
                 const safeStartIndex = Math.max(startIndex, 1); 
                 const safeEndIndex = Math.max(endIndex, 1);
                 
                 if (isExponential) {
                    // Generate more points for a smooth curve on a log-log chart
                    const points = [];
                    const numSteps = 50;
                    const step = (safeEndIndex - safeStartIndex) / numSteps;
                    for (let i = 0; i <= numSteps; i++) {
                        const x = safeStartIndex + (i * step);
                        const y = Math.pow(10, slope * x + intercept);
                        points.push({ x, y });
                    }
                    return points;
                 } else {
                    // Power law is a straight line, only need two points
                    return [
                        { x: safeStartIndex, y: Math.pow(10, slope * Math.log10(safeStartIndex) + intercept) },
                        { x: safeEndIndex, y: Math.pow(10, slope * Math.log10(safeEndIndex) + intercept) }
                    ];
                 }
            };
            
            const medianLineData = calculateLinePoints(medianIntercept);
            const p1LineData = calculateLinePoints(p1Intercept);
            const p99LineData = calculateLinePoints(p99Intercept);
            const p20LineData = calculateLinePoints(p20Intercept);
            const p80LineData = calculateLinePoints(p80Intercept);

            // The price data is always the *active* price data
            const chartPriceData = priceData.map(p => ({ x: p.x, y: p.y }));

            loader.style.display = 'none';

            // --- X-Axis Tick Generation ---
             const xAxisAfterBuildTicks = (axis) => {
                 if (!priceData || priceData.length === 0) return;
                 
                 const newTicks = [];
                 const axisMinDay = axis.min;
                 const axisMaxDay = axis.max;
                 const firstDay = priceData[0];
                 const lastDay = priceData[priceData.length - 1];
                 if (!firstDay || !lastDay) return;

                 // Map day numbers to timestamps from the *full* baseData
                 const firstBaseDay = baseData[0];
                 const lastBaseDay = baseData[baseData.length - 1];
                 
                 const minYear = new Date(firstBaseDay.time).getFullYear();
                 const maxYear = new Date(lastBaseDay.time).getFullYear() + 5; // Project 5 years out

                 let lastYearFound = -1; 
                 for (let year = minYear; year <= maxYear; year++) {
                    const yearStartTime = new Date(year, 0, 1).getTime();
                    // Find the data point in baseData for Jan 1st
                    const dayData = baseData.find(p => p.time >= yearStartTime);
                    if (!dayData) continue; // Year is too far in future

                    let xValue;
                    // Calculate the x-value for this day based on the active model
                    if (isExponential || isTruncation) { 
                        xValue = dayData.dayIndex;
                    } else {
                        xValue = dayData.dayIndex + activeModelParams.activeDayOffset;
                    }

                    if (xValue >= axisMinDay && xValue <= axisMaxDay) {
                         newTicks.push({ value: xValue, label: year.toString() });
                    }
                 }
                 
                 axis.ticks.length = 0; // Clear existing ticks
                 const validTicks = newTicks.filter(tick => !isNaN(tick.value) && tick.label);
                 axis.ticks.push(...validTicks);
             };

            // --- 5. CHART UPDATE OR CREATION ---
            const datasetDefaults = {
                type: 'line', borderWidth: 1, pointRadius: 0, fill: false, pointStyle: 'line'
            };
            const fillDatasetDefaults = {
                type: 'line', pointRadius: 0, borderWidth: 0, pointStyle: 'line', hidden: true,
            };

            if (chart) {
                // --- Update Existing Chart ---
                chart.data.datasets[0].data = chartPriceData;
                chart.data.datasets[1].data = medianLineData;
                chart.data.datasets[2].data = p1LineData;
                chart.data.datasets[3].data = p99LineData;

                const datasetsToUpdate = [
                    { index: 4, label: '20th Pctl', data: p20LineData, style: grayLineStyle, hidden: true },
                    { index: 5, label: '50th Pctl (Hidden)', data: medianLineData, style: grayLineStyle, hidden: true },
                    { index: 6, label: '80th Pctl', data: p80LineData, style: grayLineStyle, hidden: true },
                    { index: 7, label: 'Discount Band (P1-P20)', data: p20LineData, fill: 2, backgroundColor: blueFillColor, hidden: true },
                    { index: 8, label: 'Value Band (P20-P50)', data: medianLineData, fill: 4, backgroundColor: greenFillColor, hidden: true },
                    { index: 9, label: 'Expensive Band (P50-P80)', data: p80LineData, fill: 1, backgroundColor: yellowFillColor, hidden: true },
                    { index: 10, label: 'Bubble Band (P80-P99)', data: p99LineData, fill: 6, backgroundColor: redFillColor, hidden: true },
                ];

                datasetsToUpdate.forEach(dsInfo => {
                    Object.assign(chart.data.datasets[dsInfo.index], {
                        data: dsInfo.data, label: dsInfo.label, ...(dsInfo.style || {}),
                        ...(dsInfo.fill !== undefined && { fill: dsInfo.fill, backgroundColor: dsInfo.backgroundColor }),
                        hidden: dsInfo.index === 5 ? true : dsInfo.hidden,
                        tension: isExponential ? 0.1 : 0, 
                    });
                });
                // Update median line tension
                chart.data.datasets[1].tension = isExponential ? 0.1 : 0;


                 applyBandVisibility(showBandsCheckbox.checked);

                chart.options.scales.x.min = extendedMinDay;
                chart.options.scales.x.max = extendedMaxDay;
                chart.options.scales.y.min = extendedMinPrice;
                chart.options.scales.y.max = extendedMaxPrice;
                chart.options.scales.x.afterBuildTicks = xAxisAfterBuildTicks;
                chart.update();

            } else {
                // --- Create New Chart ---
                chart = new Chart(ctx, {
                    data: {
                        datasets: [
                            { ...datasetDefaults, type: 'line', label: 'TAO Price', data: chartPriceData, backgroundColor: 'rgba(0, 0, 0, 0.05)', borderColor: 'rgba(0, 0, 0, 1)', borderWidth: 2, pointHoverRadius: 5, tension: 0.1 },
                            { ...datasetDefaults, label: '50th Percentile', data: medianLineData, ...orangeLineStyle, hidden: false, tension: isExponential ? 0.1 : 0 },
                            { ...datasetDefaults, ...grayLineStyle, label: '1st Pctl', data: p1LineData, tension: isExponential ? 0.1 : 0 },
                            { ...datasetDefaults, ...grayLineStyle, label: '99th Pctl', data: p99LineData, tension: isExponential ? 0.1 : 0 },
                            { ...datasetDefaults, ...grayLineStyle, label: '20th Pctl', data: p20LineData, hidden: true, tension: isExponential ? 0.1 : 0 },
                            { ...datasetDefaults, ...grayLineStyle, label: '50th Pctl (Hidden)', data: medianLineData, hidden: true, tension: isExponential ? 0.1 : 0 },
                            { ...datasetDefaults, ...grayLineStyle, label: '80th Pctl', data: p80LineData, hidden: true, tension: isExponential ? 0.1 : 0 },
                            { ...fillDatasetDefaults, label: 'Discount Band (P1-P20)', data: p20LineData, fill: 2, backgroundColor: blueFillColor, tension: isExponential ? 0.1 : 0 },
                            { ...fillDatasetDefaults, label: 'Value Band (P20-P50)', data: medianLineData, fill: 4, backgroundColor: greenFillColor, tension: isExponential ? 0.1 : 0 },
                            { ...fillDatasetDefaults, label: 'Expensive Band (P50-P80)', data: p80LineData, fill: 1, backgroundColor: yellowFillColor, tension: isExponential ? 0.1 : 0 },
                            { ...fillDatasetDefaults, label: 'Bubble Band (P80-P99)', data: p99LineData, fill: 6, backgroundColor: redFillColor, tension: isExponential ? 0.1 : 0 },
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#374151', usePointStyle: true, boxWidth: 30, boxHeight: 12,
                                    filter: (item) => !item.text.includes('Band') && item.datasetIndex !== 5,
                                }
                            },
                            tooltip: {
                                callbacks: {
                                     title: (tooltipItems) => {
                                         if (tooltipItems.length > 0) {
                                             const item = tooltipItems[0];
                                             const dayNumber = item.parsed.x;
                                             // Find the original data point from *baseData* to get the date
                                             let dataPoint;
                                             if (item.datasetIndex === 0) {
                                                dataPoint = priceData.find(p => p.x === dayNumber);
                                             } else {
                                                // For lines, we need to estimate the date
                                                const { modelType, activeDayOffset } = activeModelParams;
                                                let targetDayIndex;
                                                if (modelType.includes('Exponential') || modelType.includes('truncation')) {
                                                    targetDayIndex = dayNumber;
                                                } else {
                                                    targetDayIndex = dayNumber - activeDayOffset;
                                                }
                                                dataPoint = baseData.find(p => p.dayIndex === Math.round(targetDayIndex));
                                             }
                                             
                                             if (dataPoint) {
                                                 const date = new Date(dataPoint.time);
                                                 return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
                                             }

                                             // Fallback for projected points
                                             const { modelType, activeDayOffset } = activeModelParams;
                                             let displayDay = 'N/A';
                                             if (!isNaN(dayNumber)) {
                                                if (modelType.includes('Exponential') || modelType.includes('truncation')) {
                                                    displayDay = dayNumber.toFixed(0); // It's just the day index
                                                } else {
                                                    displayDay = (dayNumber - activeDayOffset).toFixed(0); // It's day index + offset
                                                }
                                             }
                                             return `Day ~${displayDay}`;
                                         }
                                         return '';
                                     },
                                     label: (context) => {
                                         if (context.dataset.label.includes('Band') || context.datasetIndex === 5) return null;
                                         return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                                     }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic', min: extendedMinDay, max: extendedMaxDay,
                                title: { display: true, text: `Time (Log Scale)`, color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563', autoSkip: false,
                                    callback: function(value) {
                                        const tick = this.getTicks().find(t => t.value === value);
                                        return tick ? tick.label : null;
                                    }
                                },
                                afterBuildTicks: xAxisAfterBuildTicks, 
                                grid: { color: 'rgba(0, 0, 0, 0.1)' }
                            },
                            y: {
                                type: 'logarithmic', min: extendedMinPrice, max: extendedMaxPrice,
                                title: { display: true, text: 'Price (Log Scale)', color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563',
                                    callback: function(value, index, ticks) {
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return `$${value.toLocaleString()}`;
                                        }
                                        return ''; 
                                    }
                                },
                                grid: { 
                                    color: function(context) {
                                        const value = context.tick.value;
                                        if (value <= 0) return 'rgba(0, 0, 0, 0.1)'; 
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return 'rgba(0, 0, 0, 0.1)'; 
                                        } else {
                                            return 'rgba(0, 0, 0, 0.05)';
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // --- 6. FINAL EVENT LISTENERS ---
            showBandsContainer.classList.remove('hidden');
            showBandsCheckbox.removeEventListener('change', handleBandToggle);
            showBandsCheckbox.addEventListener('change', handleBandToggle);

            modelSelect.removeEventListener('change', createOrUpdateChart);
            modelSelect.addEventListener('change', createOrUpdateChart);

            applyBandVisibility(showBandsCheckbox.checked);
            if(chart) chart.update('none'); 
        }

        /**
         * Event handler for the "Show Bands" checkbox.
         */
        function handleBandToggle() {
             if (!chart) return;
             applyBandVisibility(showBandsCheckbox.checked);
             chart.update();
        }

        /**
         * Toggles visibility and styles for band datasets.
         */
        function applyBandVisibility(showBands) {
             if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length < 11) {
                 console.error("Chart or datasets not fully initialized for applyBandVisibility.");
                 return;
             }
             const mainMedianIndex = 1;
             const p1Index = 2; const p99Index = 3;
             const p20Index = 4; const redundantP50Index = 5; const p80Index = 6;
             const fillIndices = [7, 8, 9, 10];

             if (chart.data.datasets[0]) chart.setDatasetVisibility(0, true); // Price
             if (chart.data.datasets[mainMedianIndex]) chart.setDatasetVisibility(mainMedianIndex, true);
             if (chart.data.datasets[redundantP50Index]) chart.setDatasetVisibility(redundantP50Index, false); // Always hidden

             if (showBands) {
                 const styleToApply = grayFineLineStyle;
                 if (chart.data.datasets[p1Index]) { chart.setDatasetVisibility(p1Index, true); Object.assign(chart.data.datasets[p1Index], styleToApply); }
                 if (chart.data.datasets[p99Index]) { chart.setDatasetVisibility(p99Index, true); Object.assign(chart.data.datasets[p99Index], styleToApply); }
                 if (chart.data.datasets[p20Index]) { chart.setDatasetVisibility(p20Index, true); Object.assign(chart.data.datasets[p20Index], styleToApply); }
                 if (chart.data.datasets[p80Index]) { chart.setDatasetVisibility(p80Index, true); Object.assign(chart.data.datasets[p80Index], styleToApply); }
                 
                 fillIndices.forEach(index => { if (chart.data.datasets[index]) chart.setDatasetVisibility(index, true); });
                 const medianDataset = chart.data.datasets[mainMedianIndex];
                 if (medianDataset) Object.assign(medianDataset, grayFineLineStyle);

             } else {
                 const styleToApply = grayDashedLineStyle; 
                 if (chart.data.datasets[p1Index]) { chart.setDatasetVisibility(p1Index, true); Object.assign(chart.data.datasets[p1Index], styleToApply); }
                 if (chart.data.datasets[p99Index]) { chart.setDatasetVisibility(p99Index, true); Object.assign(chart.data.datasets[p99Index], styleToApply); }
                 if (chart.data.datasets[p20Index]) { chart.setDatasetVisibility(p20Index, false); Object.assign(chart.data.datasets[p20Index], styleToApply); }
                 if (chart.data.datasets[p80Index]) { chart.setDatasetVisibility(p80Index, false); Object.assign(chart.data.datasets[p80Index], styleToApply); }

                 fillIndices.forEach(index => { if (chart.data.datasets[index]) chart.setDatasetVisibility(index, false); });
                 const medianDataset = chart.data.datasets[mainMedianIndex];
                 if (medianDataset) Object.assign(medianDataset, orangeLineStyle);
             }
        }

        /**
         * Calculates and displays future price projections in the floating table.
         */
        function calculateProjections(baseData, modelParams, tableElement) {
            if (!baseData || baseData.length === 0 || !tableElement || !modelParams) {
                if(tableElement) tableElement.classList.add('hidden');
                return;
            }

            const { slope, meanIntercept, modelType, activeDayOffset, truncationStartIndex } = modelParams;
            const firstDataPointDate = new Date(baseData[0].time);
            const firstDayIndex = baseData[0].dayIndex; // e.g., 1
            
            const today = new Date();
            const currentYear = today.getFullYear();
            const targetDates = [
                { label: "Today", date: today },
                { label: `${currentYear + 1}`, date: new Date(currentYear + 1, 0, 1) },
                { label: `${currentYear + 2}`, date: new Date(currentYear + 2, 0, 1) },
                { label: `${currentYear + 3}`, date: new Date(currentYear + 3, 0, 1) }
            ];

            const MS_PER_DAY = 1000 * 60 * 60 * 24;

            const getDayIndex = (targetDate) => {
                const diffTime = targetDate.getTime() - firstDataPointDate.getTime();
                const diffDays = Math.round(diffTime / MS_PER_DAY);
                return firstDayIndex + diffDays;
            };

            const calculatePrice = (targetDayIndex) => {
                let dayForModel;
                if (modelType.includes('Exponential')) { 
                    // Exponential models
                    if (modelType === 'truncationExponential') {
                        const modelStartDay = baseData[truncationStartIndex].dayIndex;
                        if (targetDayIndex < modelStartDay) return NaN;
                        dayForModel = targetDayIndex;
                    } else {
                        // Offset Exponential
                        dayForModel = targetDayIndex + activeDayOffset;
                    }
                    if (dayForModel <= 0) return NaN;
                    return Math.pow(10, slope * dayForModel + meanIntercept);

                } else { 
                    // Power Law models
                    if (modelType === 'truncation') { 
                        const modelStartDay = baseData[truncationStartIndex].dayIndex;
                        if (targetDayIndex < modelStartDay) return NaN;
                        dayForModel = targetDayIndex;
                    } else {
                        // Offset Power Law
                        dayForModel = targetDayIndex + activeDayOffset;
                    }
                    if (dayForModel <= 0) return NaN;
                    return Math.pow(10, slope * Math.log10(dayForModel) + meanIntercept);
                }
            };

            // Build HTML
            let tableHtml = `
                <h3>
                    <span>Fair Value</span>
                    <button onclick="document.getElementById('projectionTable').style.display='none'" type="button" title="Close">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </h3>`;

            targetDates.forEach(item => {
                const targetDayIndex = getDayIndex(item.date);
                const projectedPrice = calculatePrice(targetDayIndex);
                const priceString = isNaN(projectedPrice) ? "N/A" : `$${projectedPrice.toFixed(2)}`;
                tableHtml += `<div><span>${item.label}</span><span>${priceString}</span></div>`;
            });

            tableElement.innerHTML = tableHtml;
            tableElement.style.display = ''; 
            tableElement.classList.remove('hidden');
        }

        // --- FULLSCREEN & MOBILE VIEW LOGIC ---

        const mainContainer = document.getElementById('mainContainer');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const fsIconEnter = document.getElementById('fsIconEnter');
        const fsIconExit = document.getElementById('fsIconExit');
        const headerElement = document.querySelector('header');
        const bottomBarElement = document.getElementById('bottomModelBar');
        const topBarElement = document.getElementById('topStatusBar');
        const chartCardElement = document.getElementById('chartCard');

        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (mainContainer.requestFullscreen) mainContainer.requestFullscreen().catch(err => console.error(`Error entering fullscreen: ${err.message}`));
                else if (mainContainer.webkitRequestFullscreen) mainContainer.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen().catch(err => console.error(`Error exiting fullscreen: ${err.message}`));
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        function handleFullscreenChange() {
             requestAnimationFrame(() => { 
                 const isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                 const isMobile = window.innerWidth < 640;
                 const isLandscape = screen.orientation ? screen.orientation.type.includes('landscape') : window.innerWidth > window.innerHeight;

                 if (isInFullscreen) {
                     fsIconEnter.classList.add('hidden');
                     fsIconExit.classList.remove('hidden');
                     fullscreenBtn.setAttribute('title', 'Exit Fullscreen');
                 } else {
                     fsIconEnter.classList.remove('hidden');
                     fsIconExit.classList.add('hidden');
                     fullscreenBtn.setAttribute('title', 'Enter Fullscreen');
                 }

                 if (headerElement) headerElement.style.display = '';
                 if (bottomBarElement) bottomBarElement.style.display = '';
                 if (topBarElement) topBarElement.style.display = '';
                 if (chartCardElement) chartCardElement.style.padding = '';

                 if (isInFullscreen && isMobile && isLandscape) {
                     if (headerElement) headerElement.style.display = 'none';
                     if (bottomBarElement) bottomBarElement.style.display = 'none';
                     if (chartCardElement) chartCardElement.style.padding = '0';
                 }

                  if (chart) {
                     setTimeout(() => {
                         requestAnimationFrame(() => {
                             if (chart) chart.resize();
                         });
                     }, 50); 
                  }
             });
        }

        // --- Event Listeners ---
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange); // Safari
        window.addEventListener('resize', handleFullscreenChange);
         if (screen.orientation) {
             screen.orientation.addEventListener('change', handleFullscreenChange);
         } else {
             window.addEventListener('orientationchange', handleFullscreenChange); // Older mobile
         }

        // Initial load
        window.onload = () => {
            createOrUpdateChart();
            // Add listener for model selection
            modelSelect.addEventListener('change', createOrUpdateChart);
            setTimeout(handleFullscreenChange, 150); // Initial check for mobile state
        }
    </script>

</body>
</html>

